/*
cgo stubs for package gomodbus.
File is generated by gopy. Do not edit.
gopy build -output=./gopy github.com/ulfaric/gomodbus
*/

package main

/*

#cgo CFLAGS: "-I/home/ursorc/.pyenv/versions/3.12.6/include/python3.12" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/home/ursorc/.pyenv/versions/3.12.6/lib" "-lpython3.12" -ldl -L/home/ursorc/.pyenv/versions/3.12.6/lib -Wl,-rpath,/home/ursorc/.pyenv/versions/3.12.6/lib -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"fmt"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"time"

	"github.com/tarm/serial"
	"github.com/ulfaric/gomodbus"
	"go.uber.org/zap"
	"go.uber.org/zap/buffer"
	"go.uber.org/zap/zapcore"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: gomodbus below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *zap.Logger
func ptrFromHandle_Ptr_zap_Logger(h CGoHandle) *zap.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*zap.Logger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zap.Logger{})).(*zap.Logger)
}
func handleFromPtr_Ptr_zap_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*zap.Logger", p))
}

// Converters for pointer handles for type: *zap.SugaredLogger
func ptrFromHandle_Ptr_zap_SugaredLogger(h CGoHandle) *zap.SugaredLogger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*zap.SugaredLogger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zap.SugaredLogger{})).(*zap.SugaredLogger)
}
func handleFromPtr_Ptr_zap_SugaredLogger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*zap.SugaredLogger", p))
}

// Converters for pointer handles for type: *buffer.Buffer
func ptrFromHandle_Ptr_buffer_Buffer(h CGoHandle) *buffer.Buffer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*buffer.Buffer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(buffer.Buffer{})).(*buffer.Buffer)
}
func handleFromPtr_Ptr_buffer_Buffer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*buffer.Buffer", p))
}

// Converters for pointer handles for type: *zapcore.CheckedEntry
func ptrFromHandle_Ptr_zapcore_CheckedEntry(h CGoHandle) *zapcore.CheckedEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*zapcore.CheckedEntry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zapcore.CheckedEntry{})).(*zapcore.CheckedEntry)
}
func handleFromPtr_Ptr_zapcore_CheckedEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*zapcore.CheckedEntry", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for non-pointer handles for type: zap.Logger
func ptrFromHandle_zap_Logger(h CGoHandle) *zap.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zap.Logger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zap.Logger{})).(*zap.Logger)
}
func handleFromPtr_zap_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zap.Logger", p))
}

// Converters for pointer handles for type: zap.Option
func ptrFromHandle_zap_Option(h CGoHandle) zap.Option {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zap.Option")
	if p == nil {
		return nil
	}
	return p.(zap.Option)
}
func handleFromPtr_zap_Option(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zap.Option", p))
}

// Converters for non-pointer handles for type: zap.SugaredLogger
func ptrFromHandle_zap_SugaredLogger(h CGoHandle) *zap.SugaredLogger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zap.SugaredLogger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zap.SugaredLogger{})).(*zap.SugaredLogger)
}
func handleFromPtr_zap_SugaredLogger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zap.SugaredLogger", p))
}

// Converters for non-pointer handles for type: buffer.Buffer
func ptrFromHandle_buffer_Buffer(h CGoHandle) *buffer.Buffer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "buffer.Buffer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(buffer.Buffer{})).(*buffer.Buffer)
}
func handleFromPtr_buffer_Buffer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("buffer.Buffer", p))
}

// Converters for pointer handles for type: zapcore.CheckWriteHook
func ptrFromHandle_zapcore_CheckWriteHook(h CGoHandle) zapcore.CheckWriteHook {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.CheckWriteHook")
	if p == nil {
		return nil
	}
	return p.(zapcore.CheckWriteHook)
}
func handleFromPtr_zapcore_CheckWriteHook(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.CheckWriteHook", p))
}

// Converters for non-pointer handles for type: zapcore.CheckedEntry
func ptrFromHandle_zapcore_CheckedEntry(h CGoHandle) *zapcore.CheckedEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.CheckedEntry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zapcore.CheckedEntry{})).(*zapcore.CheckedEntry)
}
func handleFromPtr_zapcore_CheckedEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.CheckedEntry", p))
}

// Converters for pointer handles for type: zapcore.Core
func ptrFromHandle_zapcore_Core(h CGoHandle) zapcore.Core {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.Core")
	if p == nil {
		return nil
	}
	return p.(zapcore.Core)
}
func handleFromPtr_zapcore_Core(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.Core", p))
}

// Converters for non-pointer handles for type: zapcore.Entry
func ptrFromHandle_zapcore_Entry(h CGoHandle) *zapcore.Entry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.Entry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zapcore.Entry{})).(*zapcore.Entry)
}
func handleFromPtr_zapcore_Entry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.Entry", p))
}

// Converters for non-pointer handles for type: zapcore.EntryCaller
func ptrFromHandle_zapcore_EntryCaller(h CGoHandle) *zapcore.EntryCaller {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.EntryCaller")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zapcore.EntryCaller{})).(*zapcore.EntryCaller)
}
func handleFromPtr_zapcore_EntryCaller(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.EntryCaller", p))
}

// Converters for non-pointer handles for type: zapcore.Field
func ptrFromHandle_zapcore_Field(h CGoHandle) *zapcore.Field {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.Field")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(zapcore.Field{})).(*zapcore.Field)
}
func handleFromPtr_zapcore_Field(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.Field", p))
}

// Converters for pointer handles for type: zapcore.ObjectEncoder
func ptrFromHandle_zapcore_ObjectEncoder(h CGoHandle) zapcore.ObjectEncoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.ObjectEncoder")
	if p == nil {
		return nil
	}
	return p.(zapcore.ObjectEncoder)
}
func handleFromPtr_zapcore_ObjectEncoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.ObjectEncoder", p))
}

// Converters for pointer handles for type: zapcore.WriteSyncer
func ptrFromHandle_zapcore_WriteSyncer(h CGoHandle) zapcore.WriteSyncer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "zapcore.WriteSyncer")
	if p == nil {
		return nil
	}
	return p.(zapcore.WriteSyncer)
}
func handleFromPtr_zapcore_WriteSyncer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("zapcore.WriteSyncer", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: gomodbus ---

// ---- Types ---

// Converters for pointer handles for type: *gomodbus.CustomColorEncoder
func ptrFromHandle_Ptr_gomodbus_CustomColorEncoder(h CGoHandle) *gomodbus.CustomColorEncoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.CustomColorEncoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.CustomColorEncoder{})).(*gomodbus.CustomColorEncoder)
}
func handleFromPtr_Ptr_gomodbus_CustomColorEncoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.CustomColorEncoder", p))
}

// Converters for pointer handles for type: *gomodbus.PDUErrorResponse
func ptrFromHandle_Ptr_gomodbus_PDUErrorResponse(h CGoHandle) *gomodbus.PDUErrorResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUErrorResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUErrorResponse{})).(*gomodbus.PDUErrorResponse)
}
func handleFromPtr_Ptr_gomodbus_PDUErrorResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUErrorResponse", p))
}

// Converters for pointer handles for type: *gomodbus.PDURead
func ptrFromHandle_Ptr_gomodbus_PDURead(h CGoHandle) *gomodbus.PDURead {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDURead")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDURead{})).(*gomodbus.PDURead)
}
func handleFromPtr_Ptr_gomodbus_PDURead(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDURead", p))
}

// Converters for pointer handles for type: *gomodbus.PDUReadResponse
func ptrFromHandle_Ptr_gomodbus_PDUReadResponse(h CGoHandle) *gomodbus.PDUReadResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUReadResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUReadResponse{})).(*gomodbus.PDUReadResponse)
}
func handleFromPtr_Ptr_gomodbus_PDUReadResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUReadResponse", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteMultipleCoils
func ptrFromHandle_Ptr_gomodbus_PDUWriteMultipleCoils(h CGoHandle) *gomodbus.PDUWriteMultipleCoils {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteMultipleCoils")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleCoils{})).(*gomodbus.PDUWriteMultipleCoils)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteMultipleCoils(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteMultipleCoils", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteMultipleCoilsResponse
func ptrFromHandle_Ptr_gomodbus_PDUWriteMultipleCoilsResponse(h CGoHandle) *gomodbus.PDUWriteMultipleCoilsResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteMultipleCoilsResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleCoilsResponse{})).(*gomodbus.PDUWriteMultipleCoilsResponse)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteMultipleCoilsResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteMultipleCoilsResponse", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteMultipleRegisters
func ptrFromHandle_Ptr_gomodbus_PDUWriteMultipleRegisters(h CGoHandle) *gomodbus.PDUWriteMultipleRegisters {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteMultipleRegisters")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleRegisters{})).(*gomodbus.PDUWriteMultipleRegisters)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteMultipleRegisters(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteMultipleRegisters", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteMultipleRegistersResponse
func ptrFromHandle_Ptr_gomodbus_PDUWriteMultipleRegistersResponse(h CGoHandle) *gomodbus.PDUWriteMultipleRegistersResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteMultipleRegistersResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleRegistersResponse{})).(*gomodbus.PDUWriteMultipleRegistersResponse)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteMultipleRegistersResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteMultipleRegistersResponse", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteSingleCoil
func ptrFromHandle_Ptr_gomodbus_PDUWriteSingleCoil(h CGoHandle) *gomodbus.PDUWriteSingleCoil {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteSingleCoil")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleCoil{})).(*gomodbus.PDUWriteSingleCoil)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteSingleCoil(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteSingleCoil", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteSingleCoilResponse
func ptrFromHandle_Ptr_gomodbus_PDUWriteSingleCoilResponse(h CGoHandle) *gomodbus.PDUWriteSingleCoilResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteSingleCoilResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleCoilResponse{})).(*gomodbus.PDUWriteSingleCoilResponse)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteSingleCoilResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteSingleCoilResponse", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteSingleRegister
func ptrFromHandle_Ptr_gomodbus_PDUWriteSingleRegister(h CGoHandle) *gomodbus.PDUWriteSingleRegister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteSingleRegister")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleRegister{})).(*gomodbus.PDUWriteSingleRegister)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteSingleRegister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteSingleRegister", p))
}

// Converters for pointer handles for type: *gomodbus.PDUWriteSingleRegisterResponse
func ptrFromHandle_Ptr_gomodbus_PDUWriteSingleRegisterResponse(h CGoHandle) *gomodbus.PDUWriteSingleRegisterResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.PDUWriteSingleRegisterResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleRegisterResponse{})).(*gomodbus.PDUWriteSingleRegisterResponse)
}
func handleFromPtr_Ptr_gomodbus_PDUWriteSingleRegisterResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.PDUWriteSingleRegisterResponse", p))
}

// Converters for pointer handles for type: *gomodbus.SerialADU
func ptrFromHandle_Ptr_gomodbus_SerialADU(h CGoHandle) *gomodbus.SerialADU {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.SerialADU")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.SerialADU{})).(*gomodbus.SerialADU)
}
func handleFromPtr_Ptr_gomodbus_SerialADU(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.SerialADU", p))
}

// Converters for pointer handles for type: *gomodbus.SerialClient
func ptrFromHandle_Ptr_gomodbus_SerialClient(h CGoHandle) *gomodbus.SerialClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.SerialClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.SerialClient{})).(*gomodbus.SerialClient)
}
func handleFromPtr_Ptr_gomodbus_SerialClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.SerialClient", p))
}

// Converters for pointer handles for type: *gomodbus.SerialServer
func ptrFromHandle_Ptr_gomodbus_SerialServer(h CGoHandle) *gomodbus.SerialServer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.SerialServer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer)
}
func handleFromPtr_Ptr_gomodbus_SerialServer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.SerialServer", p))
}

// Converters for pointer handles for type: *gomodbus.Slave
func ptrFromHandle_Ptr_gomodbus_Slave(h CGoHandle) *gomodbus.Slave {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.Slave")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave)
}
func handleFromPtr_Ptr_gomodbus_Slave(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.Slave", p))
}

// Converters for pointer handles for type: *gomodbus.TCPADU
func ptrFromHandle_Ptr_gomodbus_TCPADU(h CGoHandle) *gomodbus.TCPADU {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.TCPADU")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.TCPADU{})).(*gomodbus.TCPADU)
}
func handleFromPtr_Ptr_gomodbus_TCPADU(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.TCPADU", p))
}

// Converters for pointer handles for type: *gomodbus.TCPClient
func ptrFromHandle_Ptr_gomodbus_TCPClient(h CGoHandle) *gomodbus.TCPClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.TCPClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.TCPClient{})).(*gomodbus.TCPClient)
}
func handleFromPtr_Ptr_gomodbus_TCPClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.TCPClient", p))
}

// Converters for pointer handles for type: *gomodbus.TCPServer
func ptrFromHandle_Ptr_gomodbus_TCPServer(h CGoHandle) *gomodbus.TCPServer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*gomodbus.TCPServer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer)
}
func handleFromPtr_Ptr_gomodbus_TCPServer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*gomodbus.TCPServer", p))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []zap.Option
func ptrFromHandle_Slice_zap_Option(h CGoHandle) *[]zap.Option {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]zap.Option")
	if p == nil {
		return nil
	}
	return p.(*[]zap.Option)
}
func deptrFromHandle_Slice_zap_Option(h CGoHandle) []zap.Option {
	p := ptrFromHandle_Slice_zap_Option(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_zap_Option(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]zap.Option", p))
}

// --- wrapping slice: []zap.Option ---
//
//export Slice_zap_Option_CTor
func Slice_zap_Option_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_zap_Option(&[]zap.Option{}))
}

//export Slice_zap_Option_len
func Slice_zap_Option_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_zap_Option(handle))
}

//export Slice_zap_Option_elem
func Slice_zap_Option_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_zap_Option(handle)
	return handleFromPtr_zap_Option(&(s[_idx]))
}

//export Slice_zap_Option_subslice
func Slice_zap_Option_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_zap_Option(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_zap_Option(&ss))
}

//export Slice_zap_Option_set
func Slice_zap_Option_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_zap_Option(handle)
	s[_idx] = ptrFromHandle_zap_Option(_vl)
}

//export Slice_zap_Option_append
func Slice_zap_Option_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_zap_Option(handle)
	*s = append(*s, ptrFromHandle_zap_Option(_vl))
}

// Converters for implicit pointer handles for type: []zapcore.Field
func ptrFromHandle_Slice_zapcore_Field(h CGoHandle) *[]zapcore.Field {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]zapcore.Field")
	if p == nil {
		return nil
	}
	return p.(*[]zapcore.Field)
}
func deptrFromHandle_Slice_zapcore_Field(h CGoHandle) []zapcore.Field {
	p := ptrFromHandle_Slice_zapcore_Field(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_zapcore_Field(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]zapcore.Field", p))
}

// --- wrapping slice: []zapcore.Field ---
//
//export Slice_zapcore_Field_CTor
func Slice_zapcore_Field_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_zapcore_Field(&[]zapcore.Field{}))
}

//export Slice_zapcore_Field_len
func Slice_zapcore_Field_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_zapcore_Field(handle))
}

//export Slice_zapcore_Field_elem
func Slice_zapcore_Field_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_zapcore_Field(handle)
	return handleFromPtr_zapcore_Field(&(s[_idx]))
}

//export Slice_zapcore_Field_subslice
func Slice_zapcore_Field_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_zapcore_Field(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_zapcore_Field(&ss))
}

//export Slice_zapcore_Field_set
func Slice_zapcore_Field_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_zapcore_Field(handle)
	s[_idx] = *ptrFromHandle_zapcore_Field(_vl)
}

//export Slice_zapcore_Field_append
func Slice_zapcore_Field_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_zapcore_Field(handle)
	*s = append(*s, *ptrFromHandle_zapcore_Field(_vl))
}

// Converters for implicit pointer handles for type: []interface{}
func ptrFromHandle_Slice_interface_(h CGoHandle) *[]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]interface{}")
	if p == nil {
		return nil
	}
	return p.(*[]interface{})
}
func deptrFromHandle_Slice_interface_(h CGoHandle) []interface{} {
	p := ptrFromHandle_Slice_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]interface{}", p))
}

// --- wrapping slice: []interface{} ---
//
//export Slice_interface__CTor
func Slice_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_interface_(&[]interface{}{}))
}

//export Slice_interface__len
func Slice_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_interface_(handle))
}

//export Slice_interface__elem
func Slice_interface__elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_interface_(handle)
	return C.CString(fmt.Sprintf("%s", (s[_idx])))
}

//export Slice_interface__subslice
func Slice_interface__subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_interface_(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_interface_(&ss))
}

//export Slice_interface__set
func Slice_interface__set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_interface_(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_interface__append
func Slice_interface__append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_interface_(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for pointer handles for type: gomodbus.Client
func ptrFromHandle_gomodbus_Client(h CGoHandle) gomodbus.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.Client")
	if p == nil {
		return nil
	}
	return p.(gomodbus.Client)
}
func handleFromPtr_gomodbus_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.Client", p))
}

// Converters for non-pointer handles for type: gomodbus.CustomColorEncoder
func ptrFromHandle_gomodbus_CustomColorEncoder(h CGoHandle) *gomodbus.CustomColorEncoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.CustomColorEncoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.CustomColorEncoder{})).(*gomodbus.CustomColorEncoder)
}
func handleFromPtr_gomodbus_CustomColorEncoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.CustomColorEncoder", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUErrorResponse
func ptrFromHandle_gomodbus_PDUErrorResponse(h CGoHandle) *gomodbus.PDUErrorResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUErrorResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUErrorResponse{})).(*gomodbus.PDUErrorResponse)
}
func handleFromPtr_gomodbus_PDUErrorResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUErrorResponse", p))
}

// Converters for non-pointer handles for type: gomodbus.PDURead
func ptrFromHandle_gomodbus_PDURead(h CGoHandle) *gomodbus.PDURead {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDURead")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDURead{})).(*gomodbus.PDURead)
}
func handleFromPtr_gomodbus_PDURead(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDURead", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUReadResponse
func ptrFromHandle_gomodbus_PDUReadResponse(h CGoHandle) *gomodbus.PDUReadResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUReadResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUReadResponse{})).(*gomodbus.PDUReadResponse)
}
func handleFromPtr_gomodbus_PDUReadResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUReadResponse", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteMultipleCoils
func ptrFromHandle_gomodbus_PDUWriteMultipleCoils(h CGoHandle) *gomodbus.PDUWriteMultipleCoils {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteMultipleCoils")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleCoils{})).(*gomodbus.PDUWriteMultipleCoils)
}
func handleFromPtr_gomodbus_PDUWriteMultipleCoils(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteMultipleCoils", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteMultipleCoilsResponse
func ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(h CGoHandle) *gomodbus.PDUWriteMultipleCoilsResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteMultipleCoilsResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleCoilsResponse{})).(*gomodbus.PDUWriteMultipleCoilsResponse)
}
func handleFromPtr_gomodbus_PDUWriteMultipleCoilsResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteMultipleCoilsResponse", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteMultipleRegisters
func ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(h CGoHandle) *gomodbus.PDUWriteMultipleRegisters {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteMultipleRegisters")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleRegisters{})).(*gomodbus.PDUWriteMultipleRegisters)
}
func handleFromPtr_gomodbus_PDUWriteMultipleRegisters(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteMultipleRegisters", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteMultipleRegistersResponse
func ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(h CGoHandle) *gomodbus.PDUWriteMultipleRegistersResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteMultipleRegistersResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteMultipleRegistersResponse{})).(*gomodbus.PDUWriteMultipleRegistersResponse)
}
func handleFromPtr_gomodbus_PDUWriteMultipleRegistersResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteMultipleRegistersResponse", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteSingleCoil
func ptrFromHandle_gomodbus_PDUWriteSingleCoil(h CGoHandle) *gomodbus.PDUWriteSingleCoil {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteSingleCoil")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleCoil{})).(*gomodbus.PDUWriteSingleCoil)
}
func handleFromPtr_gomodbus_PDUWriteSingleCoil(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteSingleCoil", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteSingleCoilResponse
func ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(h CGoHandle) *gomodbus.PDUWriteSingleCoilResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteSingleCoilResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleCoilResponse{})).(*gomodbus.PDUWriteSingleCoilResponse)
}
func handleFromPtr_gomodbus_PDUWriteSingleCoilResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteSingleCoilResponse", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteSingleRegister
func ptrFromHandle_gomodbus_PDUWriteSingleRegister(h CGoHandle) *gomodbus.PDUWriteSingleRegister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteSingleRegister")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleRegister{})).(*gomodbus.PDUWriteSingleRegister)
}
func handleFromPtr_gomodbus_PDUWriteSingleRegister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteSingleRegister", p))
}

// Converters for non-pointer handles for type: gomodbus.PDUWriteSingleRegisterResponse
func ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(h CGoHandle) *gomodbus.PDUWriteSingleRegisterResponse {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.PDUWriteSingleRegisterResponse")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.PDUWriteSingleRegisterResponse{})).(*gomodbus.PDUWriteSingleRegisterResponse)
}
func handleFromPtr_gomodbus_PDUWriteSingleRegisterResponse(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.PDUWriteSingleRegisterResponse", p))
}

// Converters for non-pointer handles for type: gomodbus.SerialADU
func ptrFromHandle_gomodbus_SerialADU(h CGoHandle) *gomodbus.SerialADU {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.SerialADU")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.SerialADU{})).(*gomodbus.SerialADU)
}
func handleFromPtr_gomodbus_SerialADU(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.SerialADU", p))
}

// Converters for non-pointer handles for type: gomodbus.SerialClient
func ptrFromHandle_gomodbus_SerialClient(h CGoHandle) *gomodbus.SerialClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.SerialClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.SerialClient{})).(*gomodbus.SerialClient)
}
func handleFromPtr_gomodbus_SerialClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.SerialClient", p))
}

// Converters for non-pointer handles for type: gomodbus.SerialServer
func ptrFromHandle_gomodbus_SerialServer(h CGoHandle) *gomodbus.SerialServer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.SerialServer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer)
}
func handleFromPtr_gomodbus_SerialServer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.SerialServer", p))
}

// Converters for pointer handles for type: gomodbus.Server
func ptrFromHandle_gomodbus_Server(h CGoHandle) gomodbus.Server {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.Server")
	if p == nil {
		return nil
	}
	return p.(gomodbus.Server)
}
func handleFromPtr_gomodbus_Server(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.Server", p))
}

// Converters for non-pointer handles for type: gomodbus.Slave
func ptrFromHandle_gomodbus_Slave(h CGoHandle) *gomodbus.Slave {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.Slave")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave)
}
func handleFromPtr_gomodbus_Slave(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.Slave", p))
}

// Converters for non-pointer handles for type: gomodbus.TCPADU
func ptrFromHandle_gomodbus_TCPADU(h CGoHandle) *gomodbus.TCPADU {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.TCPADU")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.TCPADU{})).(*gomodbus.TCPADU)
}
func handleFromPtr_gomodbus_TCPADU(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.TCPADU", p))
}

// Converters for non-pointer handles for type: gomodbus.TCPClient
func ptrFromHandle_gomodbus_TCPClient(h CGoHandle) *gomodbus.TCPClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.TCPClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.TCPClient{})).(*gomodbus.TCPClient)
}
func handleFromPtr_gomodbus_TCPClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.TCPClient", p))
}

// Converters for non-pointer handles for type: gomodbus.TCPServer
func ptrFromHandle_gomodbus_TCPServer(h CGoHandle) *gomodbus.TCPServer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "gomodbus.TCPServer")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer)
}
func handleFromPtr_gomodbus_TCPServer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("gomodbus.TCPServer", p))
}

// Converters for implicit pointer handles for type: map[byte]*gomodbus.Slave
func ptrFromHandle_Map_byte_Ptr_gomodbus_Slave(h CGoHandle) *map[byte]*gomodbus.Slave {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[byte]*gomodbus.Slave")
	if p == nil {
		return nil
	}
	return p.(*map[byte]*gomodbus.Slave)
}
func deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(h CGoHandle) map[byte]*gomodbus.Slave {
	p := ptrFromHandle_Map_byte_Ptr_gomodbus_Slave(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_byte_Ptr_gomodbus_Slave(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[byte]*gomodbus.Slave", p))
}

// --- wrapping map: map[byte]*gomodbus.Slave ---
//
//export Map_byte_Ptr_gomodbus_Slave_CTor
func Map_byte_Ptr_gomodbus_Slave_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_byte_Ptr_gomodbus_Slave(&map[byte]*gomodbus.Slave{}))
}

//export Map_byte_Ptr_gomodbus_Slave_len
func Map_byte_Ptr_gomodbus_Slave_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(handle))
}

//export Map_byte_Ptr_gomodbus_Slave_elem
func Map_byte_Ptr_gomodbus_Slave_elem(handle CGoHandle, _ky C.char) CGoHandle {
	s := deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(handle)
	v, ok := s[byte(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_gomodbus_Slave(&v)
}

//export Map_byte_Ptr_gomodbus_Slave_contains
func Map_byte_Ptr_gomodbus_Slave_contains(handle CGoHandle, _ky C.char) C.char {
	s := deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(handle)
	_, ok := s[byte(_ky)]
	return boolGoToPy(ok)
}

//export Map_byte_Ptr_gomodbus_Slave_set
func Map_byte_Ptr_gomodbus_Slave_set(handle CGoHandle, _ky C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(handle)
	s[byte(_ky)] = ptrFromHandle_Ptr_gomodbus_Slave(_vl)
}

//export Map_byte_Ptr_gomodbus_Slave_delete
func Map_byte_Ptr_gomodbus_Slave_delete(handle CGoHandle, _ky C.char) {
	s := deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(handle)
	delete(s, byte(_ky))
}

//export Map_byte_Ptr_gomodbus_Slave_keys
func Map_byte_Ptr_gomodbus_Slave_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(handle)
	kys := make([]byte, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_byte(&kys)
}

// Converters for implicit pointer handles for type: map[byte]string
func ptrFromHandle_Map_byte_string(h CGoHandle) *map[byte]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[byte]string")
	if p == nil {
		return nil
	}
	return p.(*map[byte]string)
}
func deptrFromHandle_Map_byte_string(h CGoHandle) map[byte]string {
	p := ptrFromHandle_Map_byte_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_byte_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[byte]string", p))
}

// --- wrapping map: map[byte]string ---
//
//export Map_byte_string_CTor
func Map_byte_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_byte_string(&map[byte]string{}))
}

//export Map_byte_string_len
func Map_byte_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_byte_string(handle))
}

//export Map_byte_string_elem
func Map_byte_string_elem(handle CGoHandle, _ky C.char) *C.char {
	s := deptrFromHandle_Map_byte_string(handle)
	v, ok := s[byte(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_byte_string_contains
func Map_byte_string_contains(handle CGoHandle, _ky C.char) C.char {
	s := deptrFromHandle_Map_byte_string(handle)
	_, ok := s[byte(_ky)]
	return boolGoToPy(ok)
}

//export Map_byte_string_set
func Map_byte_string_set(handle CGoHandle, _ky C.char, _vl *C.char) {
	s := deptrFromHandle_Map_byte_string(handle)
	s[byte(_ky)] = C.GoString(_vl)
}

//export Map_byte_string_delete
func Map_byte_string_delete(handle CGoHandle, _ky C.char) {
	s := deptrFromHandle_Map_byte_string(handle)
	delete(s, byte(_ky))
}

//export Map_byte_string_keys
func Map_byte_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_byte_string(handle)
	kys := make([]byte, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_byte(&kys)
}

// Converters for implicit pointer handles for type: map[uint16][]byte
func ptrFromHandle_Map_uint16_Slice_byte(h CGoHandle) *map[uint16][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[uint16][]byte")
	if p == nil {
		return nil
	}
	return p.(*map[uint16][]byte)
}
func deptrFromHandle_Map_uint16_Slice_byte(h CGoHandle) map[uint16][]byte {
	p := ptrFromHandle_Map_uint16_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_uint16_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[uint16][]byte", p))
}

// --- wrapping map: map[uint16][]byte ---
//
//export Map_uint16_Slice_byte_CTor
func Map_uint16_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_uint16_Slice_byte(&map[uint16][]byte{}))
}

//export Map_uint16_Slice_byte_len
func Map_uint16_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_uint16_Slice_byte(handle))
}

//export Map_uint16_Slice_byte_elem
func Map_uint16_Slice_byte_elem(handle CGoHandle, _ky C.ushort) CGoHandle {
	s := deptrFromHandle_Map_uint16_Slice_byte(handle)
	v, ok := s[uint16(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_byte(&v)
}

//export Map_uint16_Slice_byte_contains
func Map_uint16_Slice_byte_contains(handle CGoHandle, _ky C.ushort) C.char {
	s := deptrFromHandle_Map_uint16_Slice_byte(handle)
	_, ok := s[uint16(_ky)]
	return boolGoToPy(ok)
}

//export Map_uint16_Slice_byte_set
func Map_uint16_Slice_byte_set(handle CGoHandle, _ky C.ushort, _vl CGoHandle) {
	s := deptrFromHandle_Map_uint16_Slice_byte(handle)
	s[uint16(_ky)] = deptrFromHandle_Slice_byte(_vl)
}

//export Map_uint16_Slice_byte_delete
func Map_uint16_Slice_byte_delete(handle CGoHandle, _ky C.ushort) {
	s := deptrFromHandle_Map_uint16_Slice_byte(handle)
	delete(s, uint16(_ky))
}

//export Map_uint16_Slice_byte_keys
func Map_uint16_Slice_byte_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_uint16_Slice_byte(handle)
	kys := make([]uint16, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_uint16(&kys)
}

// Converters for implicit pointer handles for type: map[uint16]bool
func ptrFromHandle_Map_uint16_bool(h CGoHandle) *map[uint16]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[uint16]bool")
	if p == nil {
		return nil
	}
	return p.(*map[uint16]bool)
}
func deptrFromHandle_Map_uint16_bool(h CGoHandle) map[uint16]bool {
	p := ptrFromHandle_Map_uint16_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_uint16_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[uint16]bool", p))
}

// --- wrapping map: map[uint16]bool ---
//
//export Map_uint16_bool_CTor
func Map_uint16_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_uint16_bool(&map[uint16]bool{}))
}

//export Map_uint16_bool_len
func Map_uint16_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_uint16_bool(handle))
}

//export Map_uint16_bool_elem
func Map_uint16_bool_elem(handle CGoHandle, _ky C.ushort) C.char {
	s := deptrFromHandle_Map_uint16_bool(handle)
	v, ok := s[uint16(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return boolGoToPy(v)
}

//export Map_uint16_bool_contains
func Map_uint16_bool_contains(handle CGoHandle, _ky C.ushort) C.char {
	s := deptrFromHandle_Map_uint16_bool(handle)
	_, ok := s[uint16(_ky)]
	return boolGoToPy(ok)
}

//export Map_uint16_bool_set
func Map_uint16_bool_set(handle CGoHandle, _ky C.ushort, _vl C.char) {
	s := deptrFromHandle_Map_uint16_bool(handle)
	s[uint16(_ky)] = boolPyToGo(_vl)
}

//export Map_uint16_bool_delete
func Map_uint16_bool_delete(handle CGoHandle, _ky C.ushort) {
	s := deptrFromHandle_Map_uint16_bool(handle)
	delete(s, uint16(_ky))
}

//export Map_uint16_bool_keys
func Map_uint16_bool_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_uint16_bool(handle)
	kys := make([]uint16, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_uint16(&kys)
}

// ---- Global Variables: can only use functions to access ---
//
//export gomodbus_Logger
func gomodbus_Logger() CGoHandle {
	return handleFromPtr_Ptr_zap_Logger(gomodbus.Logger)
}

//export gomodbus_Set_Logger
func gomodbus_Set_Logger(val CGoHandle) {
	gomodbus.Logger = ptrFromHandle_Ptr_zap_Logger(val)
}

//export gomodbus_ModbusException
func gomodbus_ModbusException() CGoHandle {
	return handleFromPtr_Map_byte_string(&gomodbus.ModbusException)
}

//export gomodbus_Set_ModbusException
func gomodbus_Set_ModbusException(val CGoHandle) {
	gomodbus.ModbusException = deptrFromHandle_Map_byte_string(val)
}

// ---- Interfaces ---

//export gomodbus_Client_Connect
func gomodbus_Client_Connect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(gomodbus.Client).Connect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_Client_Disconnect
func gomodbus_Client_Disconnect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(gomodbus.Client).Disconnect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_Client_ReceiveResponse
func gomodbus_Client_ReceiveResponse(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Client")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := vifc.(gomodbus.Client).ReceiveResponse()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_Client_SendRequest
func gomodbus_Client_SendRequest(_handle CGoHandle, unitID C.char, pduBytes CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(gomodbus.Client).SendRequest(byte(unitID), deptrFromHandle_Slice_byte(pduBytes))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_Server_AddSlave
func gomodbus_Server_AddSlave(_handle CGoHandle, unitID C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Server")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(gomodbus.Server).AddSlave(byte(unitID))
	} else {
		vifc.(gomodbus.Server).AddSlave(byte(unitID))
	}
}

//export gomodbus_Server_GetSlave
func gomodbus_Server_GetSlave(_handle CGoHandle, unitID C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Server")
	if __err != nil {
		return handleFromPtr_Ptr_gomodbus_Slave(nil)
	}
	cret, __err := vifc.(gomodbus.Server).GetSlave(byte(unitID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_gomodbus_Slave(nil)
	}
	return handleFromPtr_Ptr_gomodbus_Slave(cret)
}

//export gomodbus_Server_RemoveSlave
func gomodbus_Server_RemoveSlave(_handle CGoHandle, unitID C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Server")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(gomodbus.Server).RemoveSlave(byte(unitID))
	} else {
		vifc.(gomodbus.Server).RemoveSlave(byte(unitID))
	}
}

//export gomodbus_Server_Start
func gomodbus_Server_Start(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Server")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(gomodbus.Server).Start()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_Server_Stop
func gomodbus_Server_Stop(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "gomodbus.Server")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(gomodbus.Server).Stop()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Structs ---

// --- wrapping struct: gomodbus.TCPClient ---
//
//export gomodbus_TCPClient_CTor
func gomodbus_TCPClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_TCPClient(&gomodbus.TCPClient{}))
}

//export gomodbus_TCPClient_Host_Get
func gomodbus_TCPClient_Host_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	return C.CString(op.Host)
}

//export gomodbus_TCPClient_Host_Set
func gomodbus_TCPClient_Host_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	op.Host = C.GoString(val)
}

//export gomodbus_TCPClient_Port_Get
func gomodbus_TCPClient_Port_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	return C.longlong(op.Port)
}

//export gomodbus_TCPClient_Port_Set
func gomodbus_TCPClient_Port_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	op.Port = int(val)
}

//export gomodbus_TCPClient_UseTLS_Get
func gomodbus_TCPClient_UseTLS_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	return boolGoToPy(op.UseTLS)
}

//export gomodbus_TCPClient_UseTLS_Set
func gomodbus_TCPClient_UseTLS_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	op.UseTLS = boolPyToGo(val)
}

//export gomodbus_TCPClient_CertFile_Get
func gomodbus_TCPClient_CertFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	return C.CString(op.CertFile)
}

//export gomodbus_TCPClient_CertFile_Set
func gomodbus_TCPClient_CertFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	op.CertFile = C.GoString(val)
}

//export gomodbus_TCPClient_KeyFile_Get
func gomodbus_TCPClient_KeyFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	return C.CString(op.KeyFile)
}

//export gomodbus_TCPClient_KeyFile_Set
func gomodbus_TCPClient_KeyFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	op.KeyFile = C.GoString(val)
}

//export gomodbus_TCPClient_CAFile_Get
func gomodbus_TCPClient_CAFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	return C.CString(op.CAFile)
}

//export gomodbus_TCPClient_CAFile_Set
func gomodbus_TCPClient_CAFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPClient(handle)
	op.CAFile = C.GoString(val)
}

//export gomodbus_TCPClient_Connect
func gomodbus_TCPClient_Connect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPClient{})).(*gomodbus.TCPClient).Connect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_TCPClient_Disconnect
func gomodbus_TCPClient_Disconnect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPClient{})).(*gomodbus.TCPClient).Disconnect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_TCPClient_SendRequest
func gomodbus_TCPClient_SendRequest(_handle CGoHandle, unitID C.char, pduBytes CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPClient{})).(*gomodbus.TCPClient).SendRequest(byte(unitID), deptrFromHandle_Slice_byte(pduBytes))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_TCPClient_ReceiveResponse
func gomodbus_TCPClient_ReceiveResponse(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPClient")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPClient{})).(*gomodbus.TCPClient).ReceiveResponse()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

// --- wrapping struct: gomodbus.PDUErrorResponse ---
//
//export gomodbus_PDUErrorResponse_CTor
func gomodbus_PDUErrorResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUErrorResponse(&gomodbus.PDUErrorResponse{}))
}

//export gomodbus_PDUErrorResponse_FunctionCode_Get
func gomodbus_PDUErrorResponse_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUErrorResponse(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUErrorResponse_FunctionCode_Set
func gomodbus_PDUErrorResponse_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUErrorResponse(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUErrorResponse_ExceptionCode_Get
func gomodbus_PDUErrorResponse_ExceptionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUErrorResponse(handle)
	return C.char(op.ExceptionCode)
}

//export gomodbus_PDUErrorResponse_ExceptionCode_Set
func gomodbus_PDUErrorResponse_ExceptionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUErrorResponse(handle)
	op.ExceptionCode = byte(val)
}

//export gomodbus_PDUErrorResponse_ToBytes
func gomodbus_PDUErrorResponse_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUErrorResponse")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUErrorResponse{})).(*gomodbus.PDUErrorResponse).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUErrorResponse_FromBytes
func gomodbus_PDUErrorResponse_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUErrorResponse")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUErrorResponse{})).(*gomodbus.PDUErrorResponse).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteMultipleCoils ---
//
//export gomodbus_PDUWriteMultipleCoils_CTor
func gomodbus_PDUWriteMultipleCoils_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteMultipleCoils(&gomodbus.PDUWriteMultipleCoils{}))
}

//export gomodbus_PDUWriteMultipleCoils_FunctionCode_Get
func gomodbus_PDUWriteMultipleCoils_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteMultipleCoils_FunctionCode_Set
func gomodbus_PDUWriteMultipleCoils_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteMultipleCoils_StartingAddress_Get
func gomodbus_PDUWriteMultipleCoils_StartingAddress_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	return C.ushort(op.StartingAddress)
}

//export gomodbus_PDUWriteMultipleCoils_StartingAddress_Set
func gomodbus_PDUWriteMultipleCoils_StartingAddress_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	op.StartingAddress = uint16(val)
}

//export gomodbus_PDUWriteMultipleCoils_Quantity_Get
func gomodbus_PDUWriteMultipleCoils_Quantity_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	return C.ushort(op.Quantity)
}

//export gomodbus_PDUWriteMultipleCoils_Quantity_Set
func gomodbus_PDUWriteMultipleCoils_Quantity_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	op.Quantity = uint16(val)
}

//export gomodbus_PDUWriteMultipleCoils_ByteCount_Get
func gomodbus_PDUWriteMultipleCoils_ByteCount_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	return C.char(op.ByteCount)
}

//export gomodbus_PDUWriteMultipleCoils_ByteCount_Set
func gomodbus_PDUWriteMultipleCoils_ByteCount_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	op.ByteCount = byte(val)
}

//export gomodbus_PDUWriteMultipleCoils_Values_Get
func gomodbus_PDUWriteMultipleCoils_Values_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	return handleFromPtr_Slice_byte(&op.Values)
}

//export gomodbus_PDUWriteMultipleCoils_Values_Set
func gomodbus_PDUWriteMultipleCoils_Values_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoils(handle)
	op.Values = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_PDUWriteMultipleCoils_ToBytes
func gomodbus_PDUWriteMultipleCoils_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleCoils")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleCoils{})).(*gomodbus.PDUWriteMultipleCoils).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteMultipleCoils_FromBytes
func gomodbus_PDUWriteMultipleCoils_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleCoils")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleCoils{})).(*gomodbus.PDUWriteMultipleCoils).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteMultipleRegistersResponse ---
//
//export gomodbus_PDUWriteMultipleRegistersResponse_CTor
func gomodbus_PDUWriteMultipleRegistersResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteMultipleRegistersResponse(&gomodbus.PDUWriteMultipleRegistersResponse{}))
}

//export gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Get
func gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Set
func gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_Address_Get
func gomodbus_PDUWriteMultipleRegistersResponse_Address_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(handle)
	return C.ushort(op.Address)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_Address_Set
func gomodbus_PDUWriteMultipleRegistersResponse_Address_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(handle)
	op.Address = uint16(val)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Get
func gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(handle)
	return C.ushort(op.Quantity)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Set
func gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegistersResponse(handle)
	op.Quantity = uint16(val)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_ToBytes
func gomodbus_PDUWriteMultipleRegistersResponse_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleRegistersResponse")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleRegistersResponse{})).(*gomodbus.PDUWriteMultipleRegistersResponse).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteMultipleRegistersResponse_FromBytes
func gomodbus_PDUWriteMultipleRegistersResponse_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleRegistersResponse")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleRegistersResponse{})).(*gomodbus.PDUWriteMultipleRegistersResponse).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteSingleRegister ---
//
//export gomodbus_PDUWriteSingleRegister_CTor
func gomodbus_PDUWriteSingleRegister_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteSingleRegister(&gomodbus.PDUWriteSingleRegister{}))
}

//export gomodbus_PDUWriteSingleRegister_FunctionCode_Get
func gomodbus_PDUWriteSingleRegister_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegister(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteSingleRegister_FunctionCode_Set
func gomodbus_PDUWriteSingleRegister_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegister(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteSingleRegister_Address_Get
func gomodbus_PDUWriteSingleRegister_Address_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegister(handle)
	return C.ushort(op.Address)
}

//export gomodbus_PDUWriteSingleRegister_Address_Set
func gomodbus_PDUWriteSingleRegister_Address_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegister(handle)
	op.Address = uint16(val)
}

//export gomodbus_PDUWriteSingleRegister_Value_Get
func gomodbus_PDUWriteSingleRegister_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegister(handle)
	return handleFromPtr_Slice_byte(&op.Value)
}

//export gomodbus_PDUWriteSingleRegister_Value_Set
func gomodbus_PDUWriteSingleRegister_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegister(handle)
	op.Value = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_PDUWriteSingleRegister_ToBytes
func gomodbus_PDUWriteSingleRegister_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleRegister")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleRegister{})).(*gomodbus.PDUWriteSingleRegister).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteSingleRegister_FromBytes
func gomodbus_PDUWriteSingleRegister_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleRegister")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleRegister{})).(*gomodbus.PDUWriteSingleRegister).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.Slave ---
//
//export gomodbus_Slave_CTor
func gomodbus_Slave_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_Slave(&gomodbus.Slave{}))
}

//export gomodbus_Slave_Coils_Get
func gomodbus_Slave_Coils_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_Slave(handle)
	return handleFromPtr_Map_uint16_bool(&op.Coils)
}

//export gomodbus_Slave_Coils_Set
func gomodbus_Slave_Coils_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_Slave(handle)
	op.Coils = deptrFromHandle_Map_uint16_bool(val)
}

//export gomodbus_Slave_DiscreteInputs_Get
func gomodbus_Slave_DiscreteInputs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_Slave(handle)
	return handleFromPtr_Map_uint16_bool(&op.DiscreteInputs)
}

//export gomodbus_Slave_DiscreteInputs_Set
func gomodbus_Slave_DiscreteInputs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_Slave(handle)
	op.DiscreteInputs = deptrFromHandle_Map_uint16_bool(val)
}

//export gomodbus_Slave_HoldingRegisters_Get
func gomodbus_Slave_HoldingRegisters_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_Slave(handle)
	return handleFromPtr_Map_uint16_Slice_byte(&op.HoldingRegisters)
}

//export gomodbus_Slave_HoldingRegisters_Set
func gomodbus_Slave_HoldingRegisters_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_Slave(handle)
	op.HoldingRegisters = deptrFromHandle_Map_uint16_Slice_byte(val)
}

//export gomodbus_Slave_InputRegisters_Get
func gomodbus_Slave_InputRegisters_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_Slave(handle)
	return handleFromPtr_Map_uint16_Slice_byte(&op.InputRegisters)
}

//export gomodbus_Slave_InputRegisters_Set
func gomodbus_Slave_InputRegisters_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_Slave(handle)
	op.InputRegisters = deptrFromHandle_Map_uint16_Slice_byte(val)
}

//export gomodbus_Slave_AddCoils
func gomodbus_Slave_AddCoils(_handle CGoHandle, address C.ushort, values CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddCoils(uint16(address), deptrFromHandle_Slice_bool(values))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddCoils(uint16(address), deptrFromHandle_Slice_bool(values))
	}
}

//export gomodbus_Slave_DeleteCoils
func gomodbus_Slave_DeleteCoils(_handle CGoHandle, addresses CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteCoils(deptrFromHandle_Slice_uint16(addresses))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteCoils(deptrFromHandle_Slice_uint16(addresses))
	}
}

//export gomodbus_Slave_AddDiscreteInputs
func gomodbus_Slave_AddDiscreteInputs(_handle CGoHandle, address C.ushort, values CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddDiscreteInputs(uint16(address), deptrFromHandle_Slice_bool(values))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddDiscreteInputs(uint16(address), deptrFromHandle_Slice_bool(values))
	}
}

//export gomodbus_Slave_DeleteDiscreteInputs
func gomodbus_Slave_DeleteDiscreteInputs(_handle CGoHandle, addresses CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteDiscreteInputs(deptrFromHandle_Slice_uint16(addresses))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteDiscreteInputs(deptrFromHandle_Slice_uint16(addresses))
	}
}

//export gomodbus_Slave_AddHoldingRegisters
func gomodbus_Slave_AddHoldingRegisters(_handle CGoHandle, address C.ushort, values CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddHoldingRegisters(uint16(address), deptrFromHandle_Slice_Slice_byte(values))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddHoldingRegisters(uint16(address), deptrFromHandle_Slice_Slice_byte(values))
	}
}

//export gomodbus_Slave_DeleteHoldingRegisters
func gomodbus_Slave_DeleteHoldingRegisters(_handle CGoHandle, addresses CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteHoldingRegisters(deptrFromHandle_Slice_uint16(addresses))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteHoldingRegisters(deptrFromHandle_Slice_uint16(addresses))
	}
}

//export gomodbus_Slave_AddInputRegisters
func gomodbus_Slave_AddInputRegisters(_handle CGoHandle, address C.ushort, values CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddInputRegisters(uint16(address), deptrFromHandle_Slice_Slice_byte(values))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).AddInputRegisters(uint16(address), deptrFromHandle_Slice_Slice_byte(values))
	}
}

//export gomodbus_Slave_DeleteInputRegisters
func gomodbus_Slave_DeleteInputRegisters(_handle CGoHandle, addresses CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.Slave")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteInputRegisters(deptrFromHandle_Slice_uint16(addresses))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.Slave{})).(*gomodbus.Slave).DeleteInputRegisters(deptrFromHandle_Slice_uint16(addresses))
	}
}

// --- wrapping struct: gomodbus.CustomColorEncoder ---
//
//export gomodbus_CustomColorEncoder_CTor
func gomodbus_CustomColorEncoder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_CustomColorEncoder(&gomodbus.CustomColorEncoder{}))
}

//export gomodbus_CustomColorEncoder_EncodeEntry
func gomodbus_CustomColorEncoder_EncodeEntry(_handle CGoHandle, entry CGoHandle, fields CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.CustomColorEncoder")
	if __err != nil {
		return handleFromPtr_Ptr_buffer_Buffer(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.CustomColorEncoder{})).(*gomodbus.CustomColorEncoder).EncodeEntry(*ptrFromHandle_zapcore_Entry(entry), deptrFromHandle_Slice_zapcore_Field(fields))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_buffer_Buffer(nil)
	}
	return handleFromPtr_Ptr_buffer_Buffer(cret)
}

// --- wrapping struct: gomodbus.PDUReadResponse ---
//
//export gomodbus_PDUReadResponse_CTor
func gomodbus_PDUReadResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUReadResponse(&gomodbus.PDUReadResponse{}))
}

//export gomodbus_PDUReadResponse_FunctionCode_Get
func gomodbus_PDUReadResponse_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUReadResponse(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUReadResponse_FunctionCode_Set
func gomodbus_PDUReadResponse_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUReadResponse(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUReadResponse_ByteCount_Get
func gomodbus_PDUReadResponse_ByteCount_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUReadResponse(handle)
	return C.char(op.ByteCount)
}

//export gomodbus_PDUReadResponse_ByteCount_Set
func gomodbus_PDUReadResponse_ByteCount_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUReadResponse(handle)
	op.ByteCount = byte(val)
}

//export gomodbus_PDUReadResponse_Data_Get
func gomodbus_PDUReadResponse_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_PDUReadResponse(handle)
	return handleFromPtr_Slice_byte(&op.Data)
}

//export gomodbus_PDUReadResponse_Data_Set
func gomodbus_PDUReadResponse_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_PDUReadResponse(handle)
	op.Data = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_PDUReadResponse_ToBytes
func gomodbus_PDUReadResponse_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUReadResponse")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUReadResponse{})).(*gomodbus.PDUReadResponse).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUReadResponse_FromBytes
func gomodbus_PDUReadResponse_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUReadResponse")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUReadResponse{})).(*gomodbus.PDUReadResponse).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteSingleCoil ---
//
//export gomodbus_PDUWriteSingleCoil_CTor
func gomodbus_PDUWriteSingleCoil_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteSingleCoil(&gomodbus.PDUWriteSingleCoil{}))
}

//export gomodbus_PDUWriteSingleCoil_FunctionCode_Get
func gomodbus_PDUWriteSingleCoil_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoil(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteSingleCoil_FunctionCode_Set
func gomodbus_PDUWriteSingleCoil_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoil(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteSingleCoil_Address_Get
func gomodbus_PDUWriteSingleCoil_Address_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoil(handle)
	return C.ushort(op.Address)
}

//export gomodbus_PDUWriteSingleCoil_Address_Set
func gomodbus_PDUWriteSingleCoil_Address_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoil(handle)
	op.Address = uint16(val)
}

//export gomodbus_PDUWriteSingleCoil_Value_Get
func gomodbus_PDUWriteSingleCoil_Value_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoil(handle)
	return C.ushort(op.Value)
}

//export gomodbus_PDUWriteSingleCoil_Value_Set
func gomodbus_PDUWriteSingleCoil_Value_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoil(handle)
	op.Value = uint16(val)
}

//export gomodbus_PDUWriteSingleCoil_ToBytes
func gomodbus_PDUWriteSingleCoil_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleCoil")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleCoil{})).(*gomodbus.PDUWriteSingleCoil).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteSingleCoil_FromBytes
func gomodbus_PDUWriteSingleCoil_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleCoil")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleCoil{})).(*gomodbus.PDUWriteSingleCoil).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.SerialClient ---
//
//export gomodbus_SerialClient_CTor
func gomodbus_SerialClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_SerialClient(&gomodbus.SerialClient{}))
}

//export gomodbus_SerialClient_Port_Get
func gomodbus_SerialClient_Port_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	return C.CString(op.Port)
}

//export gomodbus_SerialClient_Port_Set
func gomodbus_SerialClient_Port_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	op.Port = C.GoString(val)
}

//export gomodbus_SerialClient_BaudRate_Get
func gomodbus_SerialClient_BaudRate_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	return C.longlong(op.BaudRate)
}

//export gomodbus_SerialClient_BaudRate_Set
func gomodbus_SerialClient_BaudRate_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	op.BaudRate = int(val)
}

//export gomodbus_SerialClient_DataBits_Get
func gomodbus_SerialClient_DataBits_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	return C.char(op.DataBits)
}

//export gomodbus_SerialClient_DataBits_Set
func gomodbus_SerialClient_DataBits_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	op.DataBits = byte(val)
}

//export gomodbus_SerialClient_Parity_Get
func gomodbus_SerialClient_Parity_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	return C.char(byte(op.Parity))
}

//export gomodbus_SerialClient_Parity_Set
func gomodbus_SerialClient_Parity_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	op.Parity = serial.Parity(byte(val))
}

//export gomodbus_SerialClient_StopBits_Get
func gomodbus_SerialClient_StopBits_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	return C.char(byte(op.StopBits))
}

//export gomodbus_SerialClient_StopBits_Set
func gomodbus_SerialClient_StopBits_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialClient(handle)
	op.StopBits = serial.StopBits(byte(val))
}

//export gomodbus_SerialClient_Connect
func gomodbus_SerialClient_Connect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialClient{})).(*gomodbus.SerialClient).Connect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_SerialClient_Disconnect
func gomodbus_SerialClient_Disconnect(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialClient{})).(*gomodbus.SerialClient).Disconnect()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_SerialClient_SendRequest
func gomodbus_SerialClient_SendRequest(_handle CGoHandle, unitID C.char, pduBytes CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialClient{})).(*gomodbus.SerialClient).SendRequest(byte(unitID), deptrFromHandle_Slice_byte(pduBytes))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_SerialClient_ReceiveResponse
func gomodbus_SerialClient_ReceiveResponse(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialClient")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialClient{})).(*gomodbus.SerialClient).ReceiveResponse()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

// --- wrapping struct: gomodbus.PDUWriteMultipleRegisters ---
//
//export gomodbus_PDUWriteMultipleRegisters_CTor
func gomodbus_PDUWriteMultipleRegisters_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteMultipleRegisters(&gomodbus.PDUWriteMultipleRegisters{}))
}

//export gomodbus_PDUWriteMultipleRegisters_FunctionCode_Get
func gomodbus_PDUWriteMultipleRegisters_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteMultipleRegisters_FunctionCode_Set
func gomodbus_PDUWriteMultipleRegisters_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteMultipleRegisters_StartingAddress_Get
func gomodbus_PDUWriteMultipleRegisters_StartingAddress_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	return C.ushort(op.StartingAddress)
}

//export gomodbus_PDUWriteMultipleRegisters_StartingAddress_Set
func gomodbus_PDUWriteMultipleRegisters_StartingAddress_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	op.StartingAddress = uint16(val)
}

//export gomodbus_PDUWriteMultipleRegisters_Quantity_Get
func gomodbus_PDUWriteMultipleRegisters_Quantity_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	return C.ushort(op.Quantity)
}

//export gomodbus_PDUWriteMultipleRegisters_Quantity_Set
func gomodbus_PDUWriteMultipleRegisters_Quantity_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	op.Quantity = uint16(val)
}

//export gomodbus_PDUWriteMultipleRegisters_ByteCount_Get
func gomodbus_PDUWriteMultipleRegisters_ByteCount_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	return C.char(op.ByteCount)
}

//export gomodbus_PDUWriteMultipleRegisters_ByteCount_Set
func gomodbus_PDUWriteMultipleRegisters_ByteCount_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	op.ByteCount = byte(val)
}

//export gomodbus_PDUWriteMultipleRegisters_Values_Get
func gomodbus_PDUWriteMultipleRegisters_Values_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	return handleFromPtr_Slice_byte(&op.Values)
}

//export gomodbus_PDUWriteMultipleRegisters_Values_Set
func gomodbus_PDUWriteMultipleRegisters_Values_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleRegisters(handle)
	op.Values = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_PDUWriteMultipleRegisters_ToBytes
func gomodbus_PDUWriteMultipleRegisters_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleRegisters")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleRegisters{})).(*gomodbus.PDUWriteMultipleRegisters).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteMultipleRegisters_FromBytes
func gomodbus_PDUWriteMultipleRegisters_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleRegisters")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleRegisters{})).(*gomodbus.PDUWriteMultipleRegisters).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteSingleCoilResponse ---
//
//export gomodbus_PDUWriteSingleCoilResponse_CTor
func gomodbus_PDUWriteSingleCoilResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteSingleCoilResponse(&gomodbus.PDUWriteSingleCoilResponse{}))
}

//export gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Get
func gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Set
func gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteSingleCoilResponse_Address_Get
func gomodbus_PDUWriteSingleCoilResponse_Address_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(handle)
	return C.ushort(op.Address)
}

//export gomodbus_PDUWriteSingleCoilResponse_Address_Set
func gomodbus_PDUWriteSingleCoilResponse_Address_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(handle)
	op.Address = uint16(val)
}

//export gomodbus_PDUWriteSingleCoilResponse_Value_Get
func gomodbus_PDUWriteSingleCoilResponse_Value_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(handle)
	return boolGoToPy(op.Value)
}

//export gomodbus_PDUWriteSingleCoilResponse_Value_Set
func gomodbus_PDUWriteSingleCoilResponse_Value_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleCoilResponse(handle)
	op.Value = boolPyToGo(val)
}

//export gomodbus_PDUWriteSingleCoilResponse_ToBytes
func gomodbus_PDUWriteSingleCoilResponse_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleCoilResponse")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleCoilResponse{})).(*gomodbus.PDUWriteSingleCoilResponse).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteSingleCoilResponse_FromBytes
func gomodbus_PDUWriteSingleCoilResponse_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleCoilResponse")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleCoilResponse{})).(*gomodbus.PDUWriteSingleCoilResponse).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.TCPADU ---
//
//export gomodbus_TCPADU_CTor
func gomodbus_TCPADU_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_TCPADU(&gomodbus.TCPADU{}))
}

//export gomodbus_TCPADU_TransactionID_Get
func gomodbus_TCPADU_TransactionID_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	return C.ushort(op.TransactionID)
}

//export gomodbus_TCPADU_TransactionID_Set
func gomodbus_TCPADU_TransactionID_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	op.TransactionID = uint16(val)
}

//export gomodbus_TCPADU_ProtocolID_Get
func gomodbus_TCPADU_ProtocolID_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	return C.ushort(op.ProtocolID)
}

//export gomodbus_TCPADU_ProtocolID_Set
func gomodbus_TCPADU_ProtocolID_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	op.ProtocolID = uint16(val)
}

//export gomodbus_TCPADU_Length_Get
func gomodbus_TCPADU_Length_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	return C.ushort(op.Length)
}

//export gomodbus_TCPADU_Length_Set
func gomodbus_TCPADU_Length_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	op.Length = uint16(val)
}

//export gomodbus_TCPADU_UnitID_Get
func gomodbus_TCPADU_UnitID_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	return C.char(op.UnitID)
}

//export gomodbus_TCPADU_UnitID_Set
func gomodbus_TCPADU_UnitID_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	op.UnitID = byte(val)
}

//export gomodbus_TCPADU_PDU_Get
func gomodbus_TCPADU_PDU_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	return handleFromPtr_Slice_byte(&op.PDU)
}

//export gomodbus_TCPADU_PDU_Set
func gomodbus_TCPADU_PDU_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_TCPADU(handle)
	op.PDU = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_TCPADU_ToBytes
func gomodbus_TCPADU_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPADU")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPADU{})).(*gomodbus.TCPADU).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_TCPADU_FromBytes
func gomodbus_TCPADU_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPADU")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPADU{})).(*gomodbus.TCPADU).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.SerialServer ---
//
//export gomodbus_SerialServer_CTor
func gomodbus_SerialServer_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_SerialServer(&gomodbus.SerialServer{}))
}

//export gomodbus_SerialServer_Port_Get
func gomodbus_SerialServer_Port_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	return C.CString(op.Port)
}

//export gomodbus_SerialServer_Port_Set
func gomodbus_SerialServer_Port_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	op.Port = C.GoString(val)
}

//export gomodbus_SerialServer_BaudRate_Get
func gomodbus_SerialServer_BaudRate_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	return C.longlong(op.BaudRate)
}

//export gomodbus_SerialServer_BaudRate_Set
func gomodbus_SerialServer_BaudRate_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	op.BaudRate = int(val)
}

//export gomodbus_SerialServer_DataBits_Get
func gomodbus_SerialServer_DataBits_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	return C.char(op.DataBits)
}

//export gomodbus_SerialServer_DataBits_Set
func gomodbus_SerialServer_DataBits_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	op.DataBits = byte(val)
}

//export gomodbus_SerialServer_Parity_Get
func gomodbus_SerialServer_Parity_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	return C.char(op.Parity)
}

//export gomodbus_SerialServer_Parity_Set
func gomodbus_SerialServer_Parity_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	op.Parity = byte(val)
}

//export gomodbus_SerialServer_StopBits_Get
func gomodbus_SerialServer_StopBits_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	return C.char(op.StopBits)
}

//export gomodbus_SerialServer_StopBits_Set
func gomodbus_SerialServer_StopBits_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	op.StopBits = byte(val)
}

//export gomodbus_SerialServer_Slaves_Get
func gomodbus_SerialServer_Slaves_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	return handleFromPtr_Map_byte_Ptr_gomodbus_Slave(&op.Slaves)
}

//export gomodbus_SerialServer_Slaves_Set
func gomodbus_SerialServer_Slaves_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_SerialServer(handle)
	op.Slaves = deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(val)
}

//export gomodbus_SerialServer_AddSlave
func gomodbus_SerialServer_AddSlave(_handle CGoHandle, unitID C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialServer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).AddSlave(byte(unitID))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).AddSlave(byte(unitID))
	}
}

//export gomodbus_SerialServer_GetSlave
func gomodbus_SerialServer_GetSlave(_handle CGoHandle, unitID C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialServer")
	if __err != nil {
		return handleFromPtr_Ptr_gomodbus_Slave(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).GetSlave(byte(unitID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_gomodbus_Slave(nil)
	}
	return handleFromPtr_Ptr_gomodbus_Slave(cret)
}

//export gomodbus_SerialServer_RemoveSlave
func gomodbus_SerialServer_RemoveSlave(_handle CGoHandle, unitID C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialServer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).RemoveSlave(byte(unitID))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).RemoveSlave(byte(unitID))
	}
}

//export gomodbus_SerialServer_Start
func gomodbus_SerialServer_Start(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialServer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).Start()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_SerialServer_Stop
func gomodbus_SerialServer_Stop(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialServer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialServer{})).(*gomodbus.SerialServer).Stop()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.TCPServer ---
//
//export gomodbus_TCPServer_CTor
func gomodbus_TCPServer_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_TCPServer(&gomodbus.TCPServer{}))
}

//export gomodbus_TCPServer_Host_Get
func gomodbus_TCPServer_Host_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return C.CString(op.Host)
}

//export gomodbus_TCPServer_Host_Set
func gomodbus_TCPServer_Host_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.Host = C.GoString(val)
}

//export gomodbus_TCPServer_Port_Get
func gomodbus_TCPServer_Port_Get(handle CGoHandle) C.long {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return C.long(op.Port)
}

//export gomodbus_TCPServer_Port_Set
func gomodbus_TCPServer_Port_Set(handle CGoHandle, val C.long) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.Port = int32(val)
}

//export gomodbus_TCPServer_Slaves_Get
func gomodbus_TCPServer_Slaves_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return handleFromPtr_Map_byte_Ptr_gomodbus_Slave(&op.Slaves)
}

//export gomodbus_TCPServer_Slaves_Set
func gomodbus_TCPServer_Slaves_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.Slaves = deptrFromHandle_Map_byte_Ptr_gomodbus_Slave(val)
}

//export gomodbus_TCPServer_UseTLS_Get
func gomodbus_TCPServer_UseTLS_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return boolGoToPy(op.UseTLS)
}

//export gomodbus_TCPServer_UseTLS_Set
func gomodbus_TCPServer_UseTLS_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.UseTLS = boolPyToGo(val)
}

//export gomodbus_TCPServer_CertFile_Get
func gomodbus_TCPServer_CertFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return C.CString(op.CertFile)
}

//export gomodbus_TCPServer_CertFile_Set
func gomodbus_TCPServer_CertFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.CertFile = C.GoString(val)
}

//export gomodbus_TCPServer_KeyFile_Get
func gomodbus_TCPServer_KeyFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return C.CString(op.KeyFile)
}

//export gomodbus_TCPServer_KeyFile_Set
func gomodbus_TCPServer_KeyFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.KeyFile = C.GoString(val)
}

//export gomodbus_TCPServer_CAFile_Get
func gomodbus_TCPServer_CAFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	return C.CString(op.CAFile)
}

//export gomodbus_TCPServer_CAFile_Set
func gomodbus_TCPServer_CAFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_gomodbus_TCPServer(handle)
	op.CAFile = C.GoString(val)
}

//export gomodbus_TCPServer_AddSlave
func gomodbus_TCPServer_AddSlave(_handle CGoHandle, unitID C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPServer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).AddSlave(byte(unitID))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).AddSlave(byte(unitID))
	}
}

//export gomodbus_TCPServer_GetSlave
func gomodbus_TCPServer_GetSlave(_handle CGoHandle, unitID C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPServer")
	if __err != nil {
		return handleFromPtr_Ptr_gomodbus_Slave(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).GetSlave(byte(unitID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_gomodbus_Slave(nil)
	}
	return handleFromPtr_Ptr_gomodbus_Slave(cret)
}

//export gomodbus_TCPServer_RemoveSlave
func gomodbus_TCPServer_RemoveSlave(_handle CGoHandle, unitID C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPServer")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).RemoveSlave(byte(unitID))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).RemoveSlave(byte(unitID))
	}
}

//export gomodbus_TCPServer_Start
func gomodbus_TCPServer_Start(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPServer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).Start()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_TCPServer_Stop
func gomodbus_TCPServer_Stop(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.TCPServer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.TCPServer{})).(*gomodbus.TCPServer).Stop()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDURead ---
//
//export gomodbus_PDURead_CTor
func gomodbus_PDURead_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDURead(&gomodbus.PDURead{}))
}

//export gomodbus_PDURead_FunctionCode_Get
func gomodbus_PDURead_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDURead(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDURead_FunctionCode_Set
func gomodbus_PDURead_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDURead(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDURead_StartingAddress_Get
func gomodbus_PDURead_StartingAddress_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDURead(handle)
	return C.ushort(op.StartingAddress)
}

//export gomodbus_PDURead_StartingAddress_Set
func gomodbus_PDURead_StartingAddress_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDURead(handle)
	op.StartingAddress = uint16(val)
}

//export gomodbus_PDURead_Quantity_Get
func gomodbus_PDURead_Quantity_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDURead(handle)
	return C.ushort(op.Quantity)
}

//export gomodbus_PDURead_Quantity_Set
func gomodbus_PDURead_Quantity_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDURead(handle)
	op.Quantity = uint16(val)
}

//export gomodbus_PDURead_ToBytes
func gomodbus_PDURead_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDURead")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDURead{})).(*gomodbus.PDURead).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDURead_FromBytes
func gomodbus_PDURead_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDURead")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDURead{})).(*gomodbus.PDURead).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteMultipleCoilsResponse ---
//
//export gomodbus_PDUWriteMultipleCoilsResponse_CTor
func gomodbus_PDUWriteMultipleCoilsResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteMultipleCoilsResponse(&gomodbus.PDUWriteMultipleCoilsResponse{}))
}

//export gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Get
func gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Set
func gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_Address_Get
func gomodbus_PDUWriteMultipleCoilsResponse_Address_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(handle)
	return C.ushort(op.Address)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_Address_Set
func gomodbus_PDUWriteMultipleCoilsResponse_Address_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(handle)
	op.Address = uint16(val)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Get
func gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(handle)
	return C.ushort(op.Quantity)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Set
func gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteMultipleCoilsResponse(handle)
	op.Quantity = uint16(val)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_ToBytes
func gomodbus_PDUWriteMultipleCoilsResponse_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleCoilsResponse")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleCoilsResponse{})).(*gomodbus.PDUWriteMultipleCoilsResponse).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteMultipleCoilsResponse_FromBytes
func gomodbus_PDUWriteMultipleCoilsResponse_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteMultipleCoilsResponse")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteMultipleCoilsResponse{})).(*gomodbus.PDUWriteMultipleCoilsResponse).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.PDUWriteSingleRegisterResponse ---
//
//export gomodbus_PDUWriteSingleRegisterResponse_CTor
func gomodbus_PDUWriteSingleRegisterResponse_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_PDUWriteSingleRegisterResponse(&gomodbus.PDUWriteSingleRegisterResponse{}))
}

//export gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Get
func gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(handle)
	return C.char(op.FunctionCode)
}

//export gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Set
func gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(handle)
	op.FunctionCode = byte(val)
}

//export gomodbus_PDUWriteSingleRegisterResponse_Address_Get
func gomodbus_PDUWriteSingleRegisterResponse_Address_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(handle)
	return C.ushort(op.Address)
}

//export gomodbus_PDUWriteSingleRegisterResponse_Address_Set
func gomodbus_PDUWriteSingleRegisterResponse_Address_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(handle)
	op.Address = uint16(val)
}

//export gomodbus_PDUWriteSingleRegisterResponse_Value_Get
func gomodbus_PDUWriteSingleRegisterResponse_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(handle)
	return handleFromPtr_Slice_byte(&op.Value)
}

//export gomodbus_PDUWriteSingleRegisterResponse_Value_Set
func gomodbus_PDUWriteSingleRegisterResponse_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_PDUWriteSingleRegisterResponse(handle)
	op.Value = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_PDUWriteSingleRegisterResponse_ToBytes
func gomodbus_PDUWriteSingleRegisterResponse_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleRegisterResponse")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleRegisterResponse{})).(*gomodbus.PDUWriteSingleRegisterResponse).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_PDUWriteSingleRegisterResponse_FromBytes
func gomodbus_PDUWriteSingleRegisterResponse_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.PDUWriteSingleRegisterResponse")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.PDUWriteSingleRegisterResponse{})).(*gomodbus.PDUWriteSingleRegisterResponse).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: gomodbus.SerialADU ---
//
//export gomodbus_SerialADU_CTor
func gomodbus_SerialADU_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_gomodbus_SerialADU(&gomodbus.SerialADU{}))
}

//export gomodbus_SerialADU_UnitID_Get
func gomodbus_SerialADU_UnitID_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_gomodbus_SerialADU(handle)
	return C.char(op.UnitID)
}

//export gomodbus_SerialADU_UnitID_Set
func gomodbus_SerialADU_UnitID_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_gomodbus_SerialADU(handle)
	op.UnitID = byte(val)
}

//export gomodbus_SerialADU_PDU_Get
func gomodbus_SerialADU_PDU_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_gomodbus_SerialADU(handle)
	return handleFromPtr_Slice_byte(&op.PDU)
}

//export gomodbus_SerialADU_PDU_Set
func gomodbus_SerialADU_PDU_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_gomodbus_SerialADU(handle)
	op.PDU = deptrFromHandle_Slice_byte(val)
}

//export gomodbus_SerialADU_CRC_Get
func gomodbus_SerialADU_CRC_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_gomodbus_SerialADU(handle)
	return C.ushort(op.CRC)
}

//export gomodbus_SerialADU_CRC_Set
func gomodbus_SerialADU_CRC_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_gomodbus_SerialADU(handle)
	op.CRC = uint16(val)
}

//export gomodbus_SerialADU_ToBytes
func gomodbus_SerialADU_ToBytes(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialADU")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialADU{})).(*gomodbus.SerialADU).ToBytes()

	return handleFromPtr_Slice_byte(&cret)
}

//export gomodbus_SerialADU_FromBytes
func gomodbus_SerialADU_FromBytes(_handle CGoHandle, data CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*gomodbus.SerialADU")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(gomodbus.SerialADU{})).(*gomodbus.SerialADU).FromBytes(deptrFromHandle_Slice_byte(data))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export gomodbus_NewPDUErrorResponse
func gomodbus_NewPDUErrorResponse(functionCode C.char, exceptionCode C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUErrorResponse(gomodbus.NewPDUErrorResponse(byte(functionCode), byte(exceptionCode)))

}

//export gomodbus_NewPDUWriteMultipleCoils
func gomodbus_NewPDUWriteMultipleCoils(startingAddress C.ushort, values CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteMultipleCoils(gomodbus.NewPDUWriteMultipleCoils(uint16(startingAddress), deptrFromHandle_Slice_bool(values)))

}

//export gomodbus_NewWriteMultipleRegistersResponse
func gomodbus_NewWriteMultipleRegistersResponse(address C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteMultipleRegistersResponse(gomodbus.NewWriteMultipleRegistersResponse(uint16(address), uint16(quantity)))

}

//export gomodbus_NewPDUWriteSingleRegister
func gomodbus_NewPDUWriteSingleRegister(registerAddress C.ushort, registerValue CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteSingleRegister(gomodbus.NewPDUWriteSingleRegister(uint16(registerAddress), deptrFromHandle_Slice_byte(registerValue)))

}

//export gomodbus_NewPDUReadCoilsResponse
func gomodbus_NewPDUReadCoilsResponse(coils CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUReadResponse(gomodbus.NewPDUReadCoilsResponse(deptrFromHandle_Slice_bool(coils)))

}

//export gomodbus_NewPDUReadDiscreteInputsResponse
func gomodbus_NewPDUReadDiscreteInputsResponse(inputs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUReadResponse(gomodbus.NewPDUReadDiscreteInputsResponse(deptrFromHandle_Slice_bool(inputs)))

}

//export gomodbus_NewPDUReadHoldingRegistersResponse
func gomodbus_NewPDUReadHoldingRegistersResponse(registers CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUReadResponse(gomodbus.NewPDUReadHoldingRegistersResponse(deptrFromHandle_Slice_byte(registers)))

}

//export gomodbus_NewPDUReadInputRegistersResponse
func gomodbus_NewPDUReadInputRegistersResponse(registers CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUReadResponse(gomodbus.NewPDUReadInputRegistersResponse(deptrFromHandle_Slice_byte(registers)))

}

//export gomodbus_NewPDUWriteSingleCoil
func gomodbus_NewPDUWriteSingleCoil(address C.ushort, value C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteSingleCoil(gomodbus.NewPDUWriteSingleCoil(uint16(address), boolPyToGo(value)))

}

//export gomodbus_NewPDUWriteMultipleRegisters
func gomodbus_NewPDUWriteMultipleRegisters(startingAddress C.ushort, quantity C.ushort, values CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteMultipleRegisters(gomodbus.NewPDUWriteMultipleRegisters(uint16(startingAddress), uint16(quantity), deptrFromHandle_Slice_byte(values)))

}

//export gomodbus_NewWriteSingleCoilResponse
func gomodbus_NewWriteSingleCoilResponse(address C.ushort, value C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteSingleCoilResponse(gomodbus.NewWriteSingleCoilResponse(uint16(address), boolPyToGo(value)))

}

//export gomodbus_NewTCPADU
func gomodbus_NewTCPADU(transactionID C.ushort, unitID C.char, pdu CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_TCPADU(gomodbus.NewTCPADU(uint16(transactionID), byte(unitID), deptrFromHandle_Slice_byte(pdu)))

}

//export gomodbus_NewPDUReadInputRegisters
func gomodbus_NewPDUReadInputRegisters(startingAddress C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDURead(gomodbus.NewPDUReadInputRegisters(uint16(startingAddress), uint16(quantity)))

}

//export gomodbus_NewPDUReadDiscreteInputs
func gomodbus_NewPDUReadDiscreteInputs(startingAddress C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDURead(gomodbus.NewPDUReadDiscreteInputs(uint16(startingAddress), uint16(quantity)))

}

//export gomodbus_NewPDUReadCoils
func gomodbus_NewPDUReadCoils(startingAddress C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDURead(gomodbus.NewPDUReadCoils(uint16(startingAddress), uint16(quantity)))

}

//export gomodbus_NewPDUReadHoldingRegisters
func gomodbus_NewPDUReadHoldingRegisters(startingAddress C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDURead(gomodbus.NewPDUReadHoldingRegisters(uint16(startingAddress), uint16(quantity)))

}

//export gomodbus_NewWriteMultipleCoilsResponse
func gomodbus_NewWriteMultipleCoilsResponse(address C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteMultipleCoilsResponse(gomodbus.NewWriteMultipleCoilsResponse(uint16(address), uint16(quantity)))

}

//export gomodbus_NewWriteSingleRegisterResponse
func gomodbus_NewWriteSingleRegisterResponse(address C.ushort, value CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_PDUWriteSingleRegisterResponse(gomodbus.NewWriteSingleRegisterResponse(uint16(address), deptrFromHandle_Slice_byte(value)))

}

//export gomodbus_NewSerialADU
func gomodbus_NewSerialADU(address C.char, pdu CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_gomodbus_SerialADU(gomodbus.NewSerialADU(byte(address), deptrFromHandle_Slice_byte(pdu)))

}

// ---- Functions ---

//export gomodbus_ReadDiscreteInputs
func gomodbus_ReadDiscreteInputs(c CGoHandle, unitID C.char, address C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gomodbus.ReadDiscreteInputs(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), uint16(quantity))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_bool(nil)
	}
	return handleFromPtr_Slice_bool(&cret)
}

//export gomodbus_NewSerialClient
func gomodbus_NewSerialClient(port *C.char, baudRate C.longlong, dataBits C.char, parity C.char, stopBits C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_gomodbus_Client(gomodbus.NewSerialClient(C.GoString(port), int(baudRate), byte(dataBits), serial.Parity(byte(parity)), serial.StopBits(byte(stopBits))))

}

//export gomodbus_NewSerialServer
func gomodbus_NewSerialServer(port *C.char, baudRate C.longlong, dataBits C.char, parity C.char, stopBits C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_gomodbus_Server(gomodbus.NewSerialServer(C.GoString(port), int(baudRate), byte(dataBits), byte(parity), byte(stopBits)))

}

//export gomodbus_ReadInputRegisters
func gomodbus_ReadInputRegisters(c CGoHandle, unitID C.char, address C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gomodbus.ReadInputRegisters(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), uint16(quantity))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_uint16(nil)
	}
	return handleFromPtr_Slice_uint16(&cret)
}

//export gomodbus_DeleteCoils
func gomodbus_DeleteCoils(server CGoHandle, unitID C.char, addresses CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.DeleteCoils(ptrFromHandle_gomodbus_Server(server), byte(unitID), deptrFromHandle_Slice_uint16(addresses))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_InitializeLogger
func gomodbus_InitializeLogger() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_zap_Logger(gomodbus.InitializeLogger())

}

//export gomodbus_Serializer
func gomodbus_Serializer(data *C.char, byteOrder *C.char, wordOrder *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gomodbus.Serializer(C.GoString(data), C.GoString(byteOrder), C.GoString(wordOrder))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Slice_byte(nil)
	}
	return handleFromPtr_Slice_Slice_byte(&cret)
}

//export gomodbus_AddCoils
func gomodbus_AddCoils(server CGoHandle, unitID C.char, address C.ushort, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.AddCoils(ptrFromHandle_gomodbus_Server(server), byte(unitID), uint16(address), deptrFromHandle_Slice_bool(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_AddDiscreteInputs
func gomodbus_AddDiscreteInputs(server CGoHandle, unitID C.char, address C.ushort, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.AddDiscreteInputs(ptrFromHandle_gomodbus_Server(server), byte(unitID), uint16(address), deptrFromHandle_Slice_bool(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_WriteRegister
func gomodbus_WriteRegister(c CGoHandle, unitID C.char, address C.ushort, value CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.WriteRegister(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), deptrFromHandle_Slice_byte(value))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_EnableDebug
func gomodbus_EnableDebug(goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go gomodbus.EnableDebug()
	} else {
		gomodbus.EnableDebug()
	}
}

//export gomodbus_WriteCoil
func gomodbus_WriteCoil(c CGoHandle, unitID C.char, address C.ushort, value C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.WriteCoil(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), boolPyToGo(value))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_NewTCPServer
func gomodbus_NewTCPServer(host *C.char, port C.long, useTLS C.char, certFile *C.char, keyFile *C.char, caFile *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_gomodbus_Server(gomodbus.NewTCPServer(C.GoString(host), int32(port), boolPyToGo(useTLS), C.GoString(certFile), C.GoString(keyFile), C.GoString(caFile)))

}

//export gomodbus_DeleteDiscreteInputs
func gomodbus_DeleteDiscreteInputs(server CGoHandle, unitID C.char, addresses CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.DeleteDiscreteInputs(ptrFromHandle_gomodbus_Server(server), byte(unitID), deptrFromHandle_Slice_uint16(addresses))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_NewTCPClient
func gomodbus_NewTCPClient(host *C.char, port C.longlong, useTLS C.char, certFile *C.char, keyFile *C.char, caFile *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_gomodbus_Client(gomodbus.NewTCPClient(C.GoString(host), int(port), boolPyToGo(useTLS), C.GoString(certFile), C.GoString(keyFile), C.GoString(caFile)))

}

//export gomodbus_WriteRegisters
func gomodbus_WriteRegisters(c CGoHandle, unitID C.char, address C.ushort, quantity C.ushort, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.WriteRegisters(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), uint16(quantity), deptrFromHandle_Slice_byte(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_AddInputRegisters
func gomodbus_AddInputRegisters(server CGoHandle, unitID C.char, address C.ushort, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.AddInputRegisters(ptrFromHandle_gomodbus_Server(server), byte(unitID), uint16(address), deptrFromHandle_Slice_Slice_byte(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_DeleteInputRegisters
func gomodbus_DeleteInputRegisters(server CGoHandle, unitID C.char, addresses CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.DeleteInputRegisters(ptrFromHandle_gomodbus_Server(server), byte(unitID), deptrFromHandle_Slice_uint16(addresses))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_ReadCoils
func gomodbus_ReadCoils(c CGoHandle, unitID C.char, address C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gomodbus.ReadCoils(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), uint16(quantity))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_bool(nil)
	}
	return handleFromPtr_Slice_bool(&cret)
}

//export gomodbus_ReadHoldingRegisters
func gomodbus_ReadHoldingRegisters(c CGoHandle, unitID C.char, address C.ushort, quantity C.ushort) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := gomodbus.ReadHoldingRegisters(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), uint16(quantity))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_uint16(nil)
	}
	return handleFromPtr_Slice_uint16(&cret)
}

//export gomodbus_WriteCoils
func gomodbus_WriteCoils(c CGoHandle, unitID C.char, address C.ushort, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.WriteCoils(ptrFromHandle_gomodbus_Client(c), byte(unitID), uint16(address), deptrFromHandle_Slice_bool(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_AddHoldingRegisters
func gomodbus_AddHoldingRegisters(server CGoHandle, unitID C.char, address C.ushort, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.AddHoldingRegisters(ptrFromHandle_gomodbus_Server(server), byte(unitID), uint16(address), deptrFromHandle_Slice_Slice_byte(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export gomodbus_DeleteHoldingRegisters
func gomodbus_DeleteHoldingRegisters(server CGoHandle, unitID C.char, addresses CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = gomodbus.DeleteHoldingRegisters(ptrFromHandle_gomodbus_Server(server), byte(unitID), deptrFromHandle_Slice_uint16(addresses))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}
