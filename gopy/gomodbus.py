
# python wrapper for package github.com/ulfaric/gomodbus within overall package gomodbus
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=./gopy github.com/ulfaric/gomodbus

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _gomodbus
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from gomodbus import gomodbus
# and then refer to everything using gomodbus. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Slice_Slice_byte_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gomodbus.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _gomodbus.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _gomodbus.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_gomodbus.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_gomodbus.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_gomodbus.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_gomodbus.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_gomodbus.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []zap.Option
class Slice_zap_Option(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Slice_zap_Option_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_zap_Option.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Slice_zap_Option len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gomodbus.Slice_zap_Option([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _gomodbus.Slice_zap_Option_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _gomodbus.Slice_zap_Option_len(self.handle)
				return Slice_zap_Option(handle=_gomodbus.Slice_zap_Option_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.zap_Option(handle=_gomodbus.Slice_zap_Option_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_gomodbus.Slice_zap_Option_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_zap_Option.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.zap_Option(handle=_gomodbus.Slice_zap_Option_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_gomodbus.Slice_zap_Option_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []zapcore.Field
class Slice_zapcore_Field(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Slice_zapcore_Field_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_zapcore_Field.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Slice_zapcore_Field len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gomodbus.Slice_zapcore_Field([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _gomodbus.Slice_zapcore_Field_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _gomodbus.Slice_zapcore_Field_len(self.handle)
				return Slice_zapcore_Field(handle=_gomodbus.Slice_zapcore_Field_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.zapcore_Field(handle=_gomodbus.Slice_zapcore_Field_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_gomodbus.Slice_zapcore_Field_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_zapcore_Field.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.zapcore_Field(handle=_gomodbus.Slice_zapcore_Field_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_gomodbus.Slice_zapcore_Field_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []interface{}
class Slice_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Slice_interface__CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_interface_.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Slice_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'gomodbus.Slice_interface_([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _gomodbus.Slice_interface__len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _gomodbus.Slice_interface__len(self.handle)
				return Slice_interface_(handle=_gomodbus.Slice_interface__subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _gomodbus.Slice_interface__elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_gomodbus.Slice_interface__set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_interface_.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _gomodbus.Slice_interface__elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_gomodbus.Slice_interface__append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[byte]*gomodbus.Slave
class Map_byte_Ptr_gomodbus_Slave(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Map_byte_Ptr_gomodbus_Slave_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_byte_Ptr_gomodbus_Slave.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_gomodbus.Map_byte_Ptr_gomodbus_Slave_set(self.handle, k, v)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Map_byte_Ptr_gomodbus_Slave len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'gomodbus.Map_byte_Ptr_gomodbus_Slave({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _gomodbus.Map_byte_Ptr_gomodbus_Slave_len(self.handle)
	def __getitem__(self, key):
		return Slave(handle=_gomodbus.Map_byte_Ptr_gomodbus_Slave_elem(self.handle, key))
	def __setitem__(self, key, value):
		_gomodbus.Map_byte_Ptr_gomodbus_Slave_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _gomodbus.Map_byte_Ptr_gomodbus_Slave_delete(self.handle, key)
	def keys(self):
		return go.Slice_byte(handle=_gomodbus.Map_byte_Ptr_gomodbus_Slave_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _gomodbus.Map_byte_Ptr_gomodbus_Slave_contains(self.handle, key)

# Python type for map map[byte]string
class Map_byte_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Map_byte_string_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_byte_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_gomodbus.Map_byte_string_set(self.handle, k, v)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Map_byte_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'gomodbus.Map_byte_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _gomodbus.Map_byte_string_len(self.handle)
	def __getitem__(self, key):
		return _gomodbus.Map_byte_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_gomodbus.Map_byte_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _gomodbus.Map_byte_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_byte(handle=_gomodbus.Map_byte_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _gomodbus.Map_byte_string_contains(self.handle, key)

# Python type for map map[uint16][]byte
class Map_uint16_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Map_uint16_Slice_byte_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_uint16_Slice_byte.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_gomodbus.Map_uint16_Slice_byte_set(self.handle, k, v)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Map_uint16_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'gomodbus.Map_uint16_Slice_byte({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _gomodbus.Map_uint16_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_byte(handle=_gomodbus.Map_uint16_Slice_byte_elem(self.handle, key))
	def __setitem__(self, key, value):
		_gomodbus.Map_uint16_Slice_byte_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _gomodbus.Map_uint16_Slice_byte_delete(self.handle, key)
	def keys(self):
		return go.Slice_uint16(handle=_gomodbus.Map_uint16_Slice_byte_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _gomodbus.Map_uint16_Slice_byte_contains(self.handle, key)

# Python type for map map[uint16]bool
class Map_uint16_bool(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.Map_uint16_bool_CTor()
			_gomodbus.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_uint16_bool.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_gomodbus.Map_uint16_bool_set(self.handle, k, v)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		s = 'gomodbus.Map_uint16_bool len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'gomodbus.Map_uint16_bool({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _gomodbus.Map_uint16_bool_len(self.handle)
	def __getitem__(self, key):
		return _gomodbus.Map_uint16_bool_elem(self.handle, key)
	def __setitem__(self, key, value):
		_gomodbus.Map_uint16_bool_set(self.handle, key, value)
	def __delitem__(self, key):
		return _gomodbus.Map_uint16_bool_delete(self.handle, key)
	def keys(self):
		return go.Slice_uint16(handle=_gomodbus.Map_uint16_bool_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _gomodbus.Map_uint16_bool_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
Acknowledge = 5
BigEndian = "big"
GatewayPathUnavailable = 10
GatewayTargetDeviceFailedToRespond = 11
IllegalDataAddress = 2
IllegalDataValue = 3
IllegalFunction = 1
LittleEndian = "little"
MemoryParityError = 8
NegativeAcknowledge = 7
ReadCoil = 1
ReadDiscreteInput = 2
ReadHoldingRegister = 3
ReadInputRegister = 4
SlaveDeviceBusy = 6
SlaveDeviceFailure = 4
WriteMultipleCoils = 15
WriteMultipleRegisters = 16
WriteSingleCoil = 5
WriteSingleRegister = 6


# ---- Global Variables: can only use functions to access ---
def Logger():
	"""
	Logger Gets Go Variable: gomodbus.Logger
	Global logger instance
	
	"""
	return go.Ptr_zap_Logger(handle=_gomodbus.gomodbus_Logger())

def Set_Logger(value):
	"""
	Set_Logger Sets Go Variable: gomodbus.Logger
	Global logger instance
	
	"""
	if isinstance(value, go.GoClass):
		_gomodbus.gomodbus_Set_Logger(value.handle)
	else:
		_gomodbus.gomodbus_Set_Logger(value)

def ModbusException():
	"""
	ModbusException Gets Go Variable: gomodbus.ModbusException
	ModbusExceptionMap maps Modbus exception codes to their corresponding error messages.
	
	"""
	return Map_byte_string(handle=_gomodbus.gomodbus_ModbusException())

def Set_ModbusException(value):
	"""
	Set_ModbusException Sets Go Variable: gomodbus.ModbusException
	ModbusExceptionMap maps Modbus exception codes to their corresponding error messages.
	
	"""
	if isinstance(value, go.GoClass):
		_gomodbus.gomodbus_Set_ModbusException(value.handle)
	else:
		_gomodbus.gomodbus_Set_ModbusException(value)



# ---- Interfaces ---

# Python type for interface gomodbus.Client
class Client(go.GoClass):
	"""Client interface defines the methods for a Modbus client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = 0
	def Connect(self):
		"""Connect() str"""
		return _gomodbus.gomodbus_Client_Connect(self.handle)
	def Disconnect(self):
		"""Disconnect() str"""
		return _gomodbus.gomodbus_Client_Disconnect(self.handle)
	def ReceiveResponse(self):
		"""ReceiveResponse() []int, str"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_Client_ReceiveResponse(self.handle))
	def SendRequest(self, unitID, pduBytes):
		"""SendRequest(int unitID, []int pduBytes) str"""
		return _gomodbus.gomodbus_Client_SendRequest(self.handle, unitID, pduBytes.handle)

# Python type for interface gomodbus.Server
class Server(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = 0
	def AddSlave(self, unitID, goRun=False):
		"""AddSlave(int unitID) """
		_gomodbus.gomodbus_Server_AddSlave(self.handle, unitID, goRun)
	def GetSlave(self, unitID):
		"""GetSlave(int unitID) object, str"""
		return Slave(handle=_gomodbus.gomodbus_Server_GetSlave(self.handle, unitID))
	def RemoveSlave(self, unitID, goRun=False):
		"""RemoveSlave(int unitID) """
		_gomodbus.gomodbus_Server_RemoveSlave(self.handle, unitID, goRun)
	def Start(self):
		"""Start() str"""
		return _gomodbus.gomodbus_Server_Start(self.handle)
	def Stop(self):
		"""Stop() str"""
		return _gomodbus.gomodbus_Server_Stop(self.handle)


# ---- Structs ---

# Python type for struct gomodbus.TCPClient
class TCPClient(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_TCPClient_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.Host = args[0]
			if "Host" in kwargs:
				self.Host = kwargs["Host"]
			if  1 < len(args):
				self.Port = args[1]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  3 < len(args):
				self.UseTLS = args[3]
			if "UseTLS" in kwargs:
				self.UseTLS = kwargs["UseTLS"]
			if  4 < len(args):
				self.CertFile = args[4]
			if "CertFile" in kwargs:
				self.CertFile = kwargs["CertFile"]
			if  5 < len(args):
				self.KeyFile = args[5]
			if "KeyFile" in kwargs:
				self.KeyFile = kwargs["KeyFile"]
			if  6 < len(args):
				self.CAFile = args[6]
			if "CAFile" in kwargs:
				self.CAFile = kwargs["CAFile"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.TCPClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.TCPClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Host(self):
		return _gomodbus.gomodbus_TCPClient_Host_Get(self.handle)
	@Host.setter
	def Host(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPClient_Host_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPClient_Host_Set(self.handle, value)
	@property
	def Port(self):
		return _gomodbus.gomodbus_TCPClient_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPClient_Port_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPClient_Port_Set(self.handle, value)
	@property
	def UseTLS(self):
		return _gomodbus.gomodbus_TCPClient_UseTLS_Get(self.handle)
	@UseTLS.setter
	def UseTLS(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPClient_UseTLS_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPClient_UseTLS_Set(self.handle, value)
	@property
	def CertFile(self):
		return _gomodbus.gomodbus_TCPClient_CertFile_Get(self.handle)
	@CertFile.setter
	def CertFile(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPClient_CertFile_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPClient_CertFile_Set(self.handle, value)
	@property
	def KeyFile(self):
		return _gomodbus.gomodbus_TCPClient_KeyFile_Get(self.handle)
	@KeyFile.setter
	def KeyFile(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPClient_KeyFile_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPClient_KeyFile_Set(self.handle, value)
	@property
	def CAFile(self):
		return _gomodbus.gomodbus_TCPClient_CAFile_Get(self.handle)
	@CAFile.setter
	def CAFile(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPClient_CAFile_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPClient_CAFile_Set(self.handle, value)
	def Connect(self):
		"""Connect() str"""
		return _gomodbus.gomodbus_TCPClient_Connect(self.handle)
	def Disconnect(self):
		"""Disconnect() str"""
		return _gomodbus.gomodbus_TCPClient_Disconnect(self.handle)
	def SendRequest(self, unitID, pduBytes):
		"""SendRequest(int unitID, []int pduBytes) str"""
		return _gomodbus.gomodbus_TCPClient_SendRequest(self.handle, unitID, pduBytes.handle)
	def ReceiveResponse(self):
		"""ReceiveResponse() []int, str"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_TCPClient_ReceiveResponse(self.handle))

# Python type for struct gomodbus.PDUErrorResponse
class PDUErrorResponse(go.GoClass):
	"""PDUErrorResponse represents a Modbus exception response\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUErrorResponse_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.ExceptionCode = args[1]
			if "ExceptionCode" in kwargs:
				self.ExceptionCode = kwargs["ExceptionCode"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUErrorResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUErrorResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUErrorResponse_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUErrorResponse_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUErrorResponse_FunctionCode_Set(self.handle, value)
	@property
	def ExceptionCode(self):
		return _gomodbus.gomodbus_PDUErrorResponse_ExceptionCode_Get(self.handle)
	@ExceptionCode.setter
	def ExceptionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUErrorResponse_ExceptionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUErrorResponse_ExceptionCode_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts PDUErrorResponse to bytes
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUErrorResponse_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes parses bytes into PDUErrorResponse
		"""
		return _gomodbus.gomodbus_PDUErrorResponse_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteMultipleCoils
class PDUWriteMultipleCoils(go.GoClass):
	"""PDUWriteMultipleCoils represents a Modbus PDU for writing multiple coils\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteMultipleCoils_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.StartingAddress = args[1]
			if "StartingAddress" in kwargs:
				self.StartingAddress = kwargs["StartingAddress"]
			if  2 < len(args):
				self.Quantity = args[2]
			if "Quantity" in kwargs:
				self.Quantity = kwargs["Quantity"]
			if  3 < len(args):
				self.ByteCount = args[3]
			if "ByteCount" in kwargs:
				self.ByteCount = kwargs["ByteCount"]
			if  4 < len(args):
				self.Values = args[4]
			if "Values" in kwargs:
				self.Values = kwargs["Values"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleCoils{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleCoils ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoils_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoils_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoils_FunctionCode_Set(self.handle, value)
	@property
	def StartingAddress(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoils_StartingAddress_Get(self.handle)
	@StartingAddress.setter
	def StartingAddress(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoils_StartingAddress_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoils_StartingAddress_Set(self.handle, value)
	@property
	def Quantity(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoils_Quantity_Get(self.handle)
	@Quantity.setter
	def Quantity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoils_Quantity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoils_Quantity_Set(self.handle, value)
	@property
	def ByteCount(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoils_ByteCount_Get(self.handle)
	@ByteCount.setter
	def ByteCount(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoils_ByteCount_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoils_ByteCount_Set(self.handle, value)
	@property
	def Values(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteMultipleCoils_Values_Get(self.handle))
	@Values.setter
	def Values(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoils_Values_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts the PDUWriteMultipleCoils to a byte slice
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteMultipleCoils_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes populates the PDUWriteMultipleCoils fields from a byte slice
		"""
		return _gomodbus.gomodbus_PDUWriteMultipleCoils_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteMultipleRegistersResponse
class PDUWriteMultipleRegistersResponse(go.GoClass):
	"""PDUWriteMultipleRegistersResponse represents a response for a write multiple registers request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Quantity = args[2]
			if "Quantity" in kwargs:
				self.Quantity = kwargs["Quantity"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleRegistersResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleRegistersResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_FunctionCode_Set(self.handle, value)
	@property
	def Address(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_Address_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_Address_Set(self.handle, value)
	@property
	def Quantity(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Get(self.handle)
	@Quantity.setter
	def Quantity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_Quantity_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts PDUWriteMultipleRegistersResponse to bytes
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes parses bytes into PDUWriteMultipleRegistersResponse
		"""
		return _gomodbus.gomodbus_PDUWriteMultipleRegistersResponse_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteSingleRegister
class PDUWriteSingleRegister(go.GoClass):
	"""PDUWriteSingleRegister represents a Modbus PDU for writing a single register\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteSingleRegister_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Value = args[2]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleRegister{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleRegister ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteSingleRegister_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleRegister_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleRegister_FunctionCode_Set(self.handle, value)
	@property
	def Address(self):
		return _gomodbus.gomodbus_PDUWriteSingleRegister_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleRegister_Address_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleRegister_Address_Set(self.handle, value)
	@property
	def Value(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteSingleRegister_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleRegister_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts the PDUWriteSingleRegister to a byte slice
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteSingleRegister_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes populates the PDUWriteSingleRegister fields from a byte slice
		"""
		return _gomodbus.gomodbus_PDUWriteSingleRegister_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.Slave
class Slave(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_Slave_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.Coils = args[0]
			if "Coils" in kwargs:
				self.Coils = kwargs["Coils"]
			if  1 < len(args):
				self.DiscreteInputs = args[1]
			if "DiscreteInputs" in kwargs:
				self.DiscreteInputs = kwargs["DiscreteInputs"]
			if  2 < len(args):
				self.HoldingRegisters = args[2]
			if "HoldingRegisters" in kwargs:
				self.HoldingRegisters = kwargs["HoldingRegisters"]
			if  3 < len(args):
				self.InputRegisters = args[3]
			if "InputRegisters" in kwargs:
				self.InputRegisters = kwargs["InputRegisters"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.Slave{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.Slave ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Coils(self):
		return Map_uint16_bool(handle=_gomodbus.gomodbus_Slave_Coils_Get(self.handle))
	@Coils.setter
	def Coils(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_Slave_Coils_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DiscreteInputs(self):
		return Map_uint16_bool(handle=_gomodbus.gomodbus_Slave_DiscreteInputs_Get(self.handle))
	@DiscreteInputs.setter
	def DiscreteInputs(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_Slave_DiscreteInputs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def HoldingRegisters(self):
		return Map_uint16_Slice_byte(handle=_gomodbus.gomodbus_Slave_HoldingRegisters_Get(self.handle))
	@HoldingRegisters.setter
	def HoldingRegisters(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_Slave_HoldingRegisters_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def InputRegisters(self):
		return Map_uint16_Slice_byte(handle=_gomodbus.gomodbus_Slave_InputRegisters_Get(self.handle))
	@InputRegisters.setter
	def InputRegisters(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_Slave_InputRegisters_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AddCoils(self, address, values, goRun=False):
		"""AddCoils(int address, []bool values) """
		_gomodbus.gomodbus_Slave_AddCoils(self.handle, address, values.handle, goRun)
	def DeleteCoils(self, addresses, goRun=False):
		"""DeleteCoils([]int addresses) """
		_gomodbus.gomodbus_Slave_DeleteCoils(self.handle, addresses.handle, goRun)
	def AddDiscreteInputs(self, address, values, goRun=False):
		"""AddDiscreteInputs(int address, []bool values) """
		_gomodbus.gomodbus_Slave_AddDiscreteInputs(self.handle, address, values.handle, goRun)
	def DeleteDiscreteInputs(self, addresses, goRun=False):
		"""DeleteDiscreteInputs([]int addresses) """
		_gomodbus.gomodbus_Slave_DeleteDiscreteInputs(self.handle, addresses.handle, goRun)
	def AddHoldingRegisters(self, address, values, goRun=False):
		"""AddHoldingRegisters(int address, [][]int values) """
		_gomodbus.gomodbus_Slave_AddHoldingRegisters(self.handle, address, values.handle, goRun)
	def DeleteHoldingRegisters(self, addresses, goRun=False):
		"""DeleteHoldingRegisters([]int addresses) """
		_gomodbus.gomodbus_Slave_DeleteHoldingRegisters(self.handle, addresses.handle, goRun)
	def AddInputRegisters(self, address, values, goRun=False):
		"""AddInputRegisters(int address, [][]int values) """
		_gomodbus.gomodbus_Slave_AddInputRegisters(self.handle, address, values.handle, goRun)
	def DeleteInputRegisters(self, addresses, goRun=False):
		"""DeleteInputRegisters([]int addresses) """
		_gomodbus.gomodbus_Slave_DeleteInputRegisters(self.handle, addresses.handle, goRun)

# Python type for struct gomodbus.CustomColorEncoder
class CustomColorEncoder(go.GoClass):
	"""CustomColorEncoder is a custom zapcore.Encoder that adds color to log levels\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_CustomColorEncoder_CTor()
			_gomodbus.IncRef(self.handle)
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.CustomColorEncoder{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.CustomColorEncoder ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def EncodeEntry(self, entry, fields):
		"""EncodeEntry(object entry, []object fields) object, str"""
		return go.Ptr_buffer_Buffer(handle=_gomodbus.gomodbus_CustomColorEncoder_EncodeEntry(self.handle, entry.handle, fields.handle))

# Python type for struct gomodbus.PDUReadResponse
class PDUReadResponse(go.GoClass):
	"""PDUReadResponse represents a response for a read request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUReadResponse_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.ByteCount = args[1]
			if "ByteCount" in kwargs:
				self.ByteCount = kwargs["ByteCount"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUReadResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUReadResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUReadResponse_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUReadResponse_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUReadResponse_FunctionCode_Set(self.handle, value)
	@property
	def ByteCount(self):
		return _gomodbus.gomodbus_PDUReadResponse_ByteCount_Get(self.handle)
	@ByteCount.setter
	def ByteCount(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUReadResponse_ByteCount_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUReadResponse_ByteCount_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUReadResponse_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUReadResponse_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts PDUReadResponse to bytes
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUReadResponse_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes parses bytes into PDUReadResponse
		"""
		return _gomodbus.gomodbus_PDUReadResponse_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteSingleCoil
class PDUWriteSingleCoil(go.GoClass):
	"""PDUWriteSingleCoil represents a Modbus PDU for writing a single coil\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteSingleCoil_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Value = args[2]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleCoil{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleCoil ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteSingleCoil_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleCoil_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleCoil_FunctionCode_Set(self.handle, value)
	@property
	def Address(self):
		return _gomodbus.gomodbus_PDUWriteSingleCoil_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleCoil_Address_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleCoil_Address_Set(self.handle, value)
	@property
	def Value(self):
		return _gomodbus.gomodbus_PDUWriteSingleCoil_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleCoil_Value_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleCoil_Value_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts the PDUWriteSingleCoil to a byte slice
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteSingleCoil_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes populates the PDUWriteSingleCoil fields from a byte slice
		"""
		return _gomodbus.gomodbus_PDUWriteSingleCoil_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.SerialClient
class SerialClient(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_SerialClient_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.Port = args[0]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  1 < len(args):
				self.BaudRate = args[1]
			if "BaudRate" in kwargs:
				self.BaudRate = kwargs["BaudRate"]
			if  2 < len(args):
				self.DataBits = args[2]
			if "DataBits" in kwargs:
				self.DataBits = kwargs["DataBits"]
			if  3 < len(args):
				self.Parity = args[3]
			if "Parity" in kwargs:
				self.Parity = kwargs["Parity"]
			if  4 < len(args):
				self.StopBits = args[4]
			if "StopBits" in kwargs:
				self.StopBits = kwargs["StopBits"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.SerialClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.SerialClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Port(self):
		return _gomodbus.gomodbus_SerialClient_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialClient_Port_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialClient_Port_Set(self.handle, value)
	@property
	def BaudRate(self):
		return _gomodbus.gomodbus_SerialClient_BaudRate_Get(self.handle)
	@BaudRate.setter
	def BaudRate(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialClient_BaudRate_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialClient_BaudRate_Set(self.handle, value)
	@property
	def DataBits(self):
		return _gomodbus.gomodbus_SerialClient_DataBits_Get(self.handle)
	@DataBits.setter
	def DataBits(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialClient_DataBits_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialClient_DataBits_Set(self.handle, value)
	@property
	def Parity(self):
		return _gomodbus.gomodbus_SerialClient_Parity_Get(self.handle)
	@Parity.setter
	def Parity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialClient_Parity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialClient_Parity_Set(self.handle, value)
	@property
	def StopBits(self):
		return _gomodbus.gomodbus_SerialClient_StopBits_Get(self.handle)
	@StopBits.setter
	def StopBits(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialClient_StopBits_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialClient_StopBits_Set(self.handle, value)
	def Connect(self):
		"""Connect() str"""
		return _gomodbus.gomodbus_SerialClient_Connect(self.handle)
	def Disconnect(self):
		"""Disconnect() str"""
		return _gomodbus.gomodbus_SerialClient_Disconnect(self.handle)
	def SendRequest(self, unitID, pduBytes):
		"""SendRequest(int unitID, []int pduBytes) str"""
		return _gomodbus.gomodbus_SerialClient_SendRequest(self.handle, unitID, pduBytes.handle)
	def ReceiveResponse(self):
		"""ReceiveResponse() []int, str"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_SerialClient_ReceiveResponse(self.handle))

# Python type for struct gomodbus.PDUWriteMultipleRegisters
class PDUWriteMultipleRegisters(go.GoClass):
	"""PDUWriteMultipleRegisters represents a Modbus PDU for writing multiple registers\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteMultipleRegisters_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.StartingAddress = args[1]
			if "StartingAddress" in kwargs:
				self.StartingAddress = kwargs["StartingAddress"]
			if  2 < len(args):
				self.Quantity = args[2]
			if "Quantity" in kwargs:
				self.Quantity = kwargs["Quantity"]
			if  3 < len(args):
				self.ByteCount = args[3]
			if "ByteCount" in kwargs:
				self.ByteCount = kwargs["ByteCount"]
			if  4 < len(args):
				self.Values = args[4]
			if "Values" in kwargs:
				self.Values = kwargs["Values"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleRegisters{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleRegisters ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegisters_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_FunctionCode_Set(self.handle, value)
	@property
	def StartingAddress(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegisters_StartingAddress_Get(self.handle)
	@StartingAddress.setter
	def StartingAddress(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_StartingAddress_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_StartingAddress_Set(self.handle, value)
	@property
	def Quantity(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegisters_Quantity_Get(self.handle)
	@Quantity.setter
	def Quantity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_Quantity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_Quantity_Set(self.handle, value)
	@property
	def ByteCount(self):
		return _gomodbus.gomodbus_PDUWriteMultipleRegisters_ByteCount_Get(self.handle)
	@ByteCount.setter
	def ByteCount(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_ByteCount_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_ByteCount_Set(self.handle, value)
	@property
	def Values(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteMultipleRegisters_Values_Get(self.handle))
	@Values.setter
	def Values(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleRegisters_Values_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts the PDUWriteMultipleRegisters to a byte slice
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteMultipleRegisters_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes populates the PDUWriteMultipleRegisters fields from a byte slice
		"""
		return _gomodbus.gomodbus_PDUWriteMultipleRegisters_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteSingleCoilResponse
class PDUWriteSingleCoilResponse(go.GoClass):
	"""PDUWriteSingleCoilResponse represents a response for a write single coil request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteSingleCoilResponse_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Value = args[2]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleCoilResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleCoilResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleCoilResponse_FunctionCode_Set(self.handle, value)
	@property
	def Address(self):
		return _gomodbus.gomodbus_PDUWriteSingleCoilResponse_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleCoilResponse_Address_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleCoilResponse_Address_Set(self.handle, value)
	@property
	def Value(self):
		return _gomodbus.gomodbus_PDUWriteSingleCoilResponse_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleCoilResponse_Value_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleCoilResponse_Value_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts PDUWriteSingleCoilResponse to bytes
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteSingleCoilResponse_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes parses bytes into PDUWriteSingleCoilResponse
		"""
		return _gomodbus.gomodbus_PDUWriteSingleCoilResponse_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.TCPADU
class TCPADU(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_TCPADU_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.TransactionID = args[0]
			if "TransactionID" in kwargs:
				self.TransactionID = kwargs["TransactionID"]
			if  1 < len(args):
				self.ProtocolID = args[1]
			if "ProtocolID" in kwargs:
				self.ProtocolID = kwargs["ProtocolID"]
			if  2 < len(args):
				self.Length = args[2]
			if "Length" in kwargs:
				self.Length = kwargs["Length"]
			if  3 < len(args):
				self.UnitID = args[3]
			if "UnitID" in kwargs:
				self.UnitID = kwargs["UnitID"]
			if  4 < len(args):
				self.PDU = args[4]
			if "PDU" in kwargs:
				self.PDU = kwargs["PDU"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.TCPADU{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.TCPADU ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def TransactionID(self):
		return _gomodbus.gomodbus_TCPADU_TransactionID_Get(self.handle)
	@TransactionID.setter
	def TransactionID(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPADU_TransactionID_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPADU_TransactionID_Set(self.handle, value)
	@property
	def ProtocolID(self):
		return _gomodbus.gomodbus_TCPADU_ProtocolID_Get(self.handle)
	@ProtocolID.setter
	def ProtocolID(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPADU_ProtocolID_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPADU_ProtocolID_Set(self.handle, value)
	@property
	def Length(self):
		return _gomodbus.gomodbus_TCPADU_Length_Get(self.handle)
	@Length.setter
	def Length(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPADU_Length_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPADU_Length_Set(self.handle, value)
	@property
	def UnitID(self):
		return _gomodbus.gomodbus_TCPADU_UnitID_Get(self.handle)
	@UnitID.setter
	def UnitID(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPADU_UnitID_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPADU_UnitID_Set(self.handle, value)
	@property
	def PDU(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_TCPADU_PDU_Get(self.handle))
	@PDU.setter
	def PDU(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPADU_PDU_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ToBytes(self):
		"""ToBytes() []int"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_TCPADU_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str"""
		return _gomodbus.gomodbus_TCPADU_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.SerialServer
class SerialServer(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_SerialServer_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.Port = args[0]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  1 < len(args):
				self.BaudRate = args[1]
			if "BaudRate" in kwargs:
				self.BaudRate = kwargs["BaudRate"]
			if  2 < len(args):
				self.DataBits = args[2]
			if "DataBits" in kwargs:
				self.DataBits = kwargs["DataBits"]
			if  3 < len(args):
				self.Parity = args[3]
			if "Parity" in kwargs:
				self.Parity = kwargs["Parity"]
			if  4 < len(args):
				self.StopBits = args[4]
			if "StopBits" in kwargs:
				self.StopBits = kwargs["StopBits"]
			if  5 < len(args):
				self.Slaves = args[5]
			if "Slaves" in kwargs:
				self.Slaves = kwargs["Slaves"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.SerialServer{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.SerialServer ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Port(self):
		return _gomodbus.gomodbus_SerialServer_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialServer_Port_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialServer_Port_Set(self.handle, value)
	@property
	def BaudRate(self):
		return _gomodbus.gomodbus_SerialServer_BaudRate_Get(self.handle)
	@BaudRate.setter
	def BaudRate(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialServer_BaudRate_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialServer_BaudRate_Set(self.handle, value)
	@property
	def DataBits(self):
		return _gomodbus.gomodbus_SerialServer_DataBits_Get(self.handle)
	@DataBits.setter
	def DataBits(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialServer_DataBits_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialServer_DataBits_Set(self.handle, value)
	@property
	def Parity(self):
		return _gomodbus.gomodbus_SerialServer_Parity_Get(self.handle)
	@Parity.setter
	def Parity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialServer_Parity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialServer_Parity_Set(self.handle, value)
	@property
	def StopBits(self):
		return _gomodbus.gomodbus_SerialServer_StopBits_Get(self.handle)
	@StopBits.setter
	def StopBits(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialServer_StopBits_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialServer_StopBits_Set(self.handle, value)
	@property
	def Slaves(self):
		return Map_byte_Ptr_gomodbus_Slave(handle=_gomodbus.gomodbus_SerialServer_Slaves_Get(self.handle))
	@Slaves.setter
	def Slaves(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialServer_Slaves_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AddSlave(self, unitID, goRun=False):
		"""AddSlave(int unitID) """
		_gomodbus.gomodbus_SerialServer_AddSlave(self.handle, unitID, goRun)
	def GetSlave(self, unitID):
		"""GetSlave(int unitID) object, str"""
		return Slave(handle=_gomodbus.gomodbus_SerialServer_GetSlave(self.handle, unitID))
	def RemoveSlave(self, unitID, goRun=False):
		"""RemoveSlave(int unitID) """
		_gomodbus.gomodbus_SerialServer_RemoveSlave(self.handle, unitID, goRun)
	def Start(self):
		"""Start() str"""
		return _gomodbus.gomodbus_SerialServer_Start(self.handle)
	def Stop(self):
		"""Stop() str"""
		return _gomodbus.gomodbus_SerialServer_Stop(self.handle)

# Python type for struct gomodbus.TCPServer
class TCPServer(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_TCPServer_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.Host = args[0]
			if "Host" in kwargs:
				self.Host = kwargs["Host"]
			if  1 < len(args):
				self.Port = args[1]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  2 < len(args):
				self.Slaves = args[2]
			if "Slaves" in kwargs:
				self.Slaves = kwargs["Slaves"]
			if  4 < len(args):
				self.UseTLS = args[4]
			if "UseTLS" in kwargs:
				self.UseTLS = kwargs["UseTLS"]
			if  5 < len(args):
				self.CertFile = args[5]
			if "CertFile" in kwargs:
				self.CertFile = kwargs["CertFile"]
			if  6 < len(args):
				self.KeyFile = args[6]
			if "KeyFile" in kwargs:
				self.KeyFile = kwargs["KeyFile"]
			if  7 < len(args):
				self.CAFile = args[7]
			if "CAFile" in kwargs:
				self.CAFile = kwargs["CAFile"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.TCPServer{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.TCPServer ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Host(self):
		return _gomodbus.gomodbus_TCPServer_Host_Get(self.handle)
	@Host.setter
	def Host(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_Host_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPServer_Host_Set(self.handle, value)
	@property
	def Port(self):
		return _gomodbus.gomodbus_TCPServer_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_Port_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPServer_Port_Set(self.handle, value)
	@property
	def Slaves(self):
		return Map_byte_Ptr_gomodbus_Slave(handle=_gomodbus.gomodbus_TCPServer_Slaves_Get(self.handle))
	@Slaves.setter
	def Slaves(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_Slaves_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def UseTLS(self):
		return _gomodbus.gomodbus_TCPServer_UseTLS_Get(self.handle)
	@UseTLS.setter
	def UseTLS(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_UseTLS_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPServer_UseTLS_Set(self.handle, value)
	@property
	def CertFile(self):
		return _gomodbus.gomodbus_TCPServer_CertFile_Get(self.handle)
	@CertFile.setter
	def CertFile(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_CertFile_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPServer_CertFile_Set(self.handle, value)
	@property
	def KeyFile(self):
		return _gomodbus.gomodbus_TCPServer_KeyFile_Get(self.handle)
	@KeyFile.setter
	def KeyFile(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_KeyFile_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPServer_KeyFile_Set(self.handle, value)
	@property
	def CAFile(self):
		return _gomodbus.gomodbus_TCPServer_CAFile_Get(self.handle)
	@CAFile.setter
	def CAFile(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_TCPServer_CAFile_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_TCPServer_CAFile_Set(self.handle, value)
	def AddSlave(self, unitID, goRun=False):
		"""AddSlave(int unitID) """
		_gomodbus.gomodbus_TCPServer_AddSlave(self.handle, unitID, goRun)
	def GetSlave(self, unitID):
		"""GetSlave(int unitID) object, str"""
		return Slave(handle=_gomodbus.gomodbus_TCPServer_GetSlave(self.handle, unitID))
	def RemoveSlave(self, unitID, goRun=False):
		"""RemoveSlave(int unitID) """
		_gomodbus.gomodbus_TCPServer_RemoveSlave(self.handle, unitID, goRun)
	def Start(self):
		"""Start() str"""
		return _gomodbus.gomodbus_TCPServer_Start(self.handle)
	def Stop(self):
		"""Stop() str"""
		return _gomodbus.gomodbus_TCPServer_Stop(self.handle)

# Python type for struct gomodbus.PDURead
class PDURead(go.GoClass):
	"""PDURead represents a Modbus PDU for reading operations\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDURead_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.StartingAddress = args[1]
			if "StartingAddress" in kwargs:
				self.StartingAddress = kwargs["StartingAddress"]
			if  2 < len(args):
				self.Quantity = args[2]
			if "Quantity" in kwargs:
				self.Quantity = kwargs["Quantity"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDURead{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDURead ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDURead_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDURead_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDURead_FunctionCode_Set(self.handle, value)
	@property
	def StartingAddress(self):
		return _gomodbus.gomodbus_PDURead_StartingAddress_Get(self.handle)
	@StartingAddress.setter
	def StartingAddress(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDURead_StartingAddress_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDURead_StartingAddress_Set(self.handle, value)
	@property
	def Quantity(self):
		return _gomodbus.gomodbus_PDURead_Quantity_Get(self.handle)
	@Quantity.setter
	def Quantity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDURead_Quantity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDURead_Quantity_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts the PDURead to a byte slice
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDURead_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes populates the PDURead fields from a byte slice
		"""
		return _gomodbus.gomodbus_PDURead_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteMultipleCoilsResponse
class PDUWriteMultipleCoilsResponse(go.GoClass):
	"""PDUWriteMultipleCoilsResponse represents a response for a write multiple coils request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Quantity = args[2]
			if "Quantity" in kwargs:
				self.Quantity = kwargs["Quantity"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleCoilsResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteMultipleCoilsResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_FunctionCode_Set(self.handle, value)
	@property
	def Address(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_Address_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_Address_Set(self.handle, value)
	@property
	def Quantity(self):
		return _gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Get(self.handle)
	@Quantity.setter
	def Quantity(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_Quantity_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts PDUWriteMultipleCoilsResponse to bytes
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes parses bytes into PDUWriteMultipleCoilsResponse
		"""
		return _gomodbus.gomodbus_PDUWriteMultipleCoilsResponse_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.PDUWriteSingleRegisterResponse
class PDUWriteSingleRegisterResponse(go.GoClass):
	"""PDUWriteSingleRegisterResponse represents a response for a write single register request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_PDUWriteSingleRegisterResponse_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.FunctionCode = args[0]
			if "FunctionCode" in kwargs:
				self.FunctionCode = kwargs["FunctionCode"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Value = args[2]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleRegisterResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.PDUWriteSingleRegisterResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def FunctionCode(self):
		return _gomodbus.gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Get(self.handle)
	@FunctionCode.setter
	def FunctionCode(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_FunctionCode_Set(self.handle, value)
	@property
	def Address(self):
		return _gomodbus.gomodbus_PDUWriteSingleRegisterResponse_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_Address_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_Address_Set(self.handle, value)
	@property
	def Value(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ToBytes(self):
		"""ToBytes() []int
		
		ToBytes converts PDUWriteSingleRegisterResponse to bytes
		"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_PDUWriteSingleRegisterResponse_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str
		
		FromBytes parses bytes into PDUWriteSingleRegisterResponse
		"""
		return _gomodbus.gomodbus_PDUWriteSingleRegisterResponse_FromBytes(self.handle, data.handle)

# Python type for struct gomodbus.SerialADU
class SerialADU(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_gomodbus.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_gomodbus.IncRef(self.handle)
		else:
			self.handle = _gomodbus.gomodbus_SerialADU_CTor()
			_gomodbus.IncRef(self.handle)
			if  0 < len(args):
				self.UnitID = args[0]
			if "UnitID" in kwargs:
				self.UnitID = kwargs["UnitID"]
			if  1 < len(args):
				self.PDU = args[1]
			if "PDU" in kwargs:
				self.PDU = kwargs["PDU"]
			if  2 < len(args):
				self.CRC = args[2]
			if "CRC" in kwargs:
				self.CRC = kwargs["CRC"]
	def __del__(self):
		_gomodbus.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.SerialADU{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'gomodbus.SerialADU ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def UnitID(self):
		return _gomodbus.gomodbus_SerialADU_UnitID_Get(self.handle)
	@UnitID.setter
	def UnitID(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialADU_UnitID_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialADU_UnitID_Set(self.handle, value)
	@property
	def PDU(self):
		return go.Slice_byte(handle=_gomodbus.gomodbus_SerialADU_PDU_Get(self.handle))
	@PDU.setter
	def PDU(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialADU_PDU_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CRC(self):
		return _gomodbus.gomodbus_SerialADU_CRC_Get(self.handle)
	@CRC.setter
	def CRC(self, value):
		if isinstance(value, go.GoClass):
			_gomodbus.gomodbus_SerialADU_CRC_Set(self.handle, value.handle)
		else:
			_gomodbus.gomodbus_SerialADU_CRC_Set(self.handle, value)
	def ToBytes(self):
		"""ToBytes() []int"""
		return go.Slice_byte(handle=_gomodbus.gomodbus_SerialADU_ToBytes(self.handle))
	def FromBytes(self, data):
		"""FromBytes([]int data) str"""
		return _gomodbus.gomodbus_SerialADU_FromBytes(self.handle, data.handle)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewPDUErrorResponse(functionCode, exceptionCode):
	"""NewPDUErrorResponse(int functionCode, int exceptionCode) object
	
	NewPDUErrorResponse creates a new PDUErrorResponse
	"""
	return PDUErrorResponse(handle=_gomodbus.gomodbus_NewPDUErrorResponse(functionCode, exceptionCode))
def NewPDUWriteMultipleCoils(startingAddress, values):
	"""NewPDUWriteMultipleCoils(int startingAddress, []bool values) object
	
	NewPDUWriteMultipleCoils creates a new PDU for writing multiple coils
	"""
	return PDUWriteMultipleCoils(handle=_gomodbus.gomodbus_NewPDUWriteMultipleCoils(startingAddress, values.handle))
def NewWriteMultipleRegistersResponse(address, quantity):
	"""NewWriteMultipleRegistersResponse(int address, int quantity) object
	
	NewWriteMultipleRegistersResponse creates a new PDUWriteMultipleRegistersResponse
	"""
	return PDUWriteMultipleRegistersResponse(handle=_gomodbus.gomodbus_NewWriteMultipleRegistersResponse(address, quantity))
def NewPDUWriteSingleRegister(registerAddress, registerValue):
	"""NewPDUWriteSingleRegister(int registerAddress, []int registerValue) object
	
	NewPDUWriteSingleRegister creates a new PDU for writing a single register
	"""
	return PDUWriteSingleRegister(handle=_gomodbus.gomodbus_NewPDUWriteSingleRegister(registerAddress, registerValue.handle))
def NewPDUReadCoilsResponse(coils):
	"""NewPDUReadCoilsResponse([]bool coils) object
	
	NewPDUReadCoilsResponse creates a new PDUReadResponse for reading coils
	"""
	return PDUReadResponse(handle=_gomodbus.gomodbus_NewPDUReadCoilsResponse(coils.handle))
def NewPDUReadDiscreteInputsResponse(inputs):
	"""NewPDUReadDiscreteInputsResponse([]bool inputs) object
	
	NewPDUReadDiscreteInputsResponse creates a new PDUReadResponse for reading discrete inputs
	"""
	return PDUReadResponse(handle=_gomodbus.gomodbus_NewPDUReadDiscreteInputsResponse(inputs.handle))
def NewPDUReadHoldingRegistersResponse(registers):
	"""NewPDUReadHoldingRegistersResponse([]int registers) object
	
	NewPDUReadHoldingRegistersResponse creates a new PDUReadResponse for reading holding registers
	"""
	return PDUReadResponse(handle=_gomodbus.gomodbus_NewPDUReadHoldingRegistersResponse(registers.handle))
def NewPDUReadInputRegistersResponse(registers):
	"""NewPDUReadInputRegistersResponse([]int registers) object
	
	NewPDUReadInputRegistersResponse creates a new PDUReadResponse for reading input registers
	"""
	return PDUReadResponse(handle=_gomodbus.gomodbus_NewPDUReadInputRegistersResponse(registers.handle))
def NewPDUWriteSingleCoil(address, value):
	"""NewPDUWriteSingleCoil(int address, bool value) object
	
	NewPDUWriteSingleCoil creates a new PDU for writing a single coil
	"""
	return PDUWriteSingleCoil(handle=_gomodbus.gomodbus_NewPDUWriteSingleCoil(address, value))
def NewPDUWriteMultipleRegisters(startingAddress, quantity, values):
	"""NewPDUWriteMultipleRegisters(int startingAddress, int quantity, []int values) object
	
	NewPDUWriteMultipleRegisters creates a new PDU for writing multiple registers
	"""
	return PDUWriteMultipleRegisters(handle=_gomodbus.gomodbus_NewPDUWriteMultipleRegisters(startingAddress, quantity, values.handle))
def NewWriteSingleCoilResponse(address, value):
	"""NewWriteSingleCoilResponse(int address, bool value) object
	
	NewWriteSingleCoilResponse creates a new PDUWriteSingleCoilResponse
	"""
	return PDUWriteSingleCoilResponse(handle=_gomodbus.gomodbus_NewWriteSingleCoilResponse(address, value))
def NewTCPADU(transactionID, unitID, pdu):
	"""NewTCPADU(int transactionID, int unitID, []int pdu) object"""
	return TCPADU(handle=_gomodbus.gomodbus_NewTCPADU(transactionID, unitID, pdu.handle))
def NewPDUReadInputRegisters(startingAddress, quantity):
	"""NewPDUReadInputRegisters(int startingAddress, int quantity) object
	
	NewPDUReadInputRegisters creates a new PDU for reading input registers
	"""
	return PDURead(handle=_gomodbus.gomodbus_NewPDUReadInputRegisters(startingAddress, quantity))
def NewPDUReadDiscreteInputs(startingAddress, quantity):
	"""NewPDUReadDiscreteInputs(int startingAddress, int quantity) object
	
	NewPDUReadDiscreteInputs creates a new PDU for reading discrete inputs
	"""
	return PDURead(handle=_gomodbus.gomodbus_NewPDUReadDiscreteInputs(startingAddress, quantity))
def NewPDUReadCoils(startingAddress, quantity):
	"""NewPDUReadCoils(int startingAddress, int quantity) object
	
	NewPDUReadCoils creates a new PDU for reading coils
	"""
	return PDURead(handle=_gomodbus.gomodbus_NewPDUReadCoils(startingAddress, quantity))
def NewPDUReadHoldingRegisters(startingAddress, quantity):
	"""NewPDUReadHoldingRegisters(int startingAddress, int quantity) object
	
	NewPDUReadHoldingRegisters creates a new PDU for reading holding registers
	"""
	return PDURead(handle=_gomodbus.gomodbus_NewPDUReadHoldingRegisters(startingAddress, quantity))
def NewWriteMultipleCoilsResponse(address, quantity):
	"""NewWriteMultipleCoilsResponse(int address, int quantity) object
	
	NewWriteMultipleCoilsResponse creates a new PDUWriteMultipleCoilsResponse
	"""
	return PDUWriteMultipleCoilsResponse(handle=_gomodbus.gomodbus_NewWriteMultipleCoilsResponse(address, quantity))
def NewWriteSingleRegisterResponse(address, value):
	"""NewWriteSingleRegisterResponse(int address, []int value) object
	
	NewWriteSingleRegisterResponse creates a new PDUWriteSingleRegisterResponse
	"""
	return PDUWriteSingleRegisterResponse(handle=_gomodbus.gomodbus_NewWriteSingleRegisterResponse(address, value.handle))
def NewSerialADU(address, pdu):
	"""NewSerialADU(int address, []int pdu) object"""
	return SerialADU(handle=_gomodbus.gomodbus_NewSerialADU(address, pdu.handle))


# ---- Functions ---
def ReadDiscreteInputs(c, unitID, address, quantity):
	"""ReadDiscreteInputs(object c, int unitID, int address, int quantity) []bool, str
	
	ReadDiscreteInputs reads the status of discrete inputs from a Modbus server
	"""
	return go.Slice_bool(handle=_gomodbus.gomodbus_ReadDiscreteInputs(c.handle, unitID, address, quantity))
def NewSerialClient(port, baudRate, dataBits, parity, stopBits):
	"""NewSerialClient(str port, int baudRate, int dataBits, int parity, int stopBits) object"""
	return Client(handle=_gomodbus.gomodbus_NewSerialClient(port, baudRate, dataBits, parity, stopBits))
def NewSerialServer(port, baudRate, dataBits, parity, stopBits):
	"""NewSerialServer(str port, int baudRate, int dataBits, int parity, int stopBits) object"""
	return Server(handle=_gomodbus.gomodbus_NewSerialServer(port, baudRate, dataBits, parity, stopBits))
def ReadInputRegisters(c, unitID, address, quantity):
	"""ReadInputRegisters(object c, int unitID, int address, int quantity) []int, str
	
	ReadInputRegisters reads the values of input registers from a Modbus server
	"""
	return go.Slice_uint16(handle=_gomodbus.gomodbus_ReadInputRegisters(c.handle, unitID, address, quantity))
def DeleteCoils(server, unitID, addresses):
	"""DeleteCoils(object server, int unitID, []int addresses) str"""
	return _gomodbus.gomodbus_DeleteCoils(server.handle, unitID, addresses.handle)
def InitializeLogger():
	"""InitializeLogger() object
	
	InitializeLogger initializes a reusable zap logger with color support
	"""
	return go.Ptr_zap_Logger(handle=_gomodbus.gomodbus_InitializeLogger())
def Serializer(data, byteOrder, wordOrder):
	"""Serializer(str data, str byteOrder, str wordOrder) [][]int, str"""
	return Slice_Slice_byte(handle=_gomodbus.gomodbus_Serializer(data, byteOrder, wordOrder))
def AddCoils(server, unitID, address, values):
	"""AddCoils(object server, int unitID, int address, []bool values) str"""
	return _gomodbus.gomodbus_AddCoils(server.handle, unitID, address, values.handle)
def AddDiscreteInputs(server, unitID, address, values):
	"""AddDiscreteInputs(object server, int unitID, int address, []bool values) str"""
	return _gomodbus.gomodbus_AddDiscreteInputs(server.handle, unitID, address, values.handle)
def WriteRegister(c, unitID, address, value):
	"""WriteRegister(object c, int unitID, int address, []int value) str
	
	WriteRegister writes a single register value to a Modbus server
	"""
	return _gomodbus.gomodbus_WriteRegister(c.handle, unitID, address, value.handle)
def EnableDebug(goRun=False):
	"""EnableDebug() 
	
	EnableDebug enables debug level logging for the global logger
	"""
	_gomodbus.gomodbus_EnableDebug(goRun)
def WriteCoil(c, unitID, address, value):
	"""WriteCoil(object c, int unitID, int address, bool value) str
	
	WriteCoil writes a single coil value to a Modbus server
	"""
	return _gomodbus.gomodbus_WriteCoil(c.handle, unitID, address, value)
def NewTCPServer(host, port, useTLS, certFile, keyFile, caFile):
	"""NewTCPServer(str host, int port, bool useTLS, str certFile, str keyFile, str caFile) object"""
	return Server(handle=_gomodbus.gomodbus_NewTCPServer(host, port, useTLS, certFile, keyFile, caFile))
def DeleteDiscreteInputs(server, unitID, addresses):
	"""DeleteDiscreteInputs(object server, int unitID, []int addresses) str"""
	return _gomodbus.gomodbus_DeleteDiscreteInputs(server.handle, unitID, addresses.handle)
def NewTCPClient(host, port, useTLS, certFile, keyFile, caFile):
	"""NewTCPClient(str host, int port, bool useTLS, str certFile, str keyFile, str caFile) object"""
	return Client(handle=_gomodbus.gomodbus_NewTCPClient(host, port, useTLS, certFile, keyFile, caFile))
def WriteRegisters(c, unitID, address, quantity, values):
	"""WriteRegisters(object c, int unitID, int address, int quantity, []int values) str
	
	WriteRegisters writes multiple register values to a Modbus server
	"""
	return _gomodbus.gomodbus_WriteRegisters(c.handle, unitID, address, quantity, values.handle)
def AddInputRegisters(server, unitID, address, values):
	"""AddInputRegisters(object server, int unitID, int address, [][]int values) str"""
	return _gomodbus.gomodbus_AddInputRegisters(server.handle, unitID, address, values.handle)
def DeleteInputRegisters(server, unitID, addresses):
	"""DeleteInputRegisters(object server, int unitID, []int addresses) str"""
	return _gomodbus.gomodbus_DeleteInputRegisters(server.handle, unitID, addresses.handle)
def ReadCoils(c, unitID, address, quantity):
	"""ReadCoils(object c, int unitID, int address, int quantity) []bool, str
	
	ReadCoils reads the status of coils from a Modbus server
	"""
	return go.Slice_bool(handle=_gomodbus.gomodbus_ReadCoils(c.handle, unitID, address, quantity))
def ReadHoldingRegisters(c, unitID, address, quantity):
	"""ReadHoldingRegisters(object c, int unitID, int address, int quantity) []int, str
	
	ReadHoldingRegisters reads the values of holding registers from a Modbus server
	"""
	return go.Slice_uint16(handle=_gomodbus.gomodbus_ReadHoldingRegisters(c.handle, unitID, address, quantity))
def WriteCoils(c, unitID, address, values):
	"""WriteCoils(object c, int unitID, int address, []bool values) str
	
	WriteCoils writes multiple coil values to a Modbus server
	"""
	return _gomodbus.gomodbus_WriteCoils(c.handle, unitID, address, values.handle)
def AddHoldingRegisters(server, unitID, address, values):
	"""AddHoldingRegisters(object server, int unitID, int address, [][]int values) str"""
	return _gomodbus.gomodbus_AddHoldingRegisters(server.handle, unitID, address, values.handle)
def DeleteHoldingRegisters(server, unitID, addresses):
	"""DeleteHoldingRegisters(object server, int unitID, []int addresses) str"""
	return _gomodbus.gomodbus_DeleteHoldingRegisters(server.handle, unitID, addresses.handle)


